{"version":3,"file":"containerRegistryChallengeHandler.js","sourceRoot":"","sources":["../../src/containerRegistryChallengeHandler.ts"],"names":[],"mappings":"AAAA,uCAAuC;AACvC,kCAAkC;AAQlC,OAAO,EAAE,oBAAoB,EAAE,MAAM,+BAA+B,CAAC;AAKrE,OAAO,EAAwB,iBAAiB,EAAE,MAAM,qBAAqB,CAAC;AAE9E,MAAM,eAAe,GAAG,CAAC,GAAG,EAAE,GAAG,IAAI,CAAC;AAEtC;;;;;;;;;;;;;;;;;GAiBG;AACH,MAAM,OAAO,gBAAgB;IAE3B,YACU,UAAmD,EACnD,UAAiD,EAAE;QADnD,eAAU,GAAV,UAAU,CAAyC;QACnD,YAAO,GAAP,OAAO,CAA4C;QAE3D,IAAI,CAAC,MAAM,GAAG,iBAAiB,CAAC,UAAU,EAAE;YAC1C,iBAAiB,EAAE,eAAe;SACnC,CAAC,CAAC;IACL,CAAC;IAED,gBAAgB,CAAC,QAAiC;QAChD,OAAO,OAAO,CAAC,OAAO,EAAE,CAAC;IAC3B,CAAC;IAED;;OAEG;IACH,KAAK,CAAC,2BAA2B,CAAC,OAA2C;;QAC3E,2CAA2C;QAC3C,MAAM,SAAS,GAAG,MAAA,OAAO,CAAC,QAAQ,0CAAE,OAAO,CAAC,GAAG,CAAC,kBAAkB,CAAC,CAAC;QACpE,IAAI,CAAC,SAAS,EAAE;YACd,MAAM,IAAI,KAAK,CAAC,oDAAoD,CAAC,CAAC;SACvE;QACD,iGAAiG;QACjG,MAAM,EAAE,OAAO,EAAE,KAAK,EAAE,GAAG,oBAAoB,CAAC,SAAS,CAAC,CAAC;QAE3D,IAAI,CAAC,OAAO,EAAE;YACZ,MAAM,IAAI,KAAK,CAAC,6CAA6C,CAAC,CAAC;SAChE;QAED,IAAI,CAAC,KAAK,EAAE;YACV,MAAM,IAAI,KAAK,CAAC,2CAA2C,CAAC,CAAC;SAC9D;QAED,0DAA0D;QAC1D,sGAAsG;QACtG,0FAA0F;QAC1F,IAAI,SAAuC,CAAC;QAC5C,IAAI,eAAuB,CAAC;QAC5B,IAAI,IAAI,CAAC,UAAU,CAAC,iBAAiB,EAAE;YACrC,SAAS,GAAG,UAAU,CAAC;YACvB,eAAe,GAAG,EAAE,CAAC;SACtB;aAAM;YACL,SAAS,GAAG,eAAe,CAAC;YAC5B,eAAe,GAAG,CAAC,MAAM,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,KAAK,kCAAO,OAAO,KAAE,OAAO,IAAG,CAAC,CAAC,KAAK,CAAC;SACtF;QAED,8DAA8D;QAC9D,MAAM,cAAc,GAClB,MAAM,IAAI,CAAC,UAAU,CAAC,YAAY,CAAC,6CAA6C,CAC9E,eAAe,EACf,OAAO,EACP,KAAK,EACL,SAAS,EACT,IAAI,CAAC,OAAO,CACb,CAAC;QAEJ,gGAAgG;QAChG,OAAO,CAAC,OAAO,CAAC,OAAO,CAAC,GAAG,CAAC,eAAe,EAAE,UAAU,cAAc,EAAE,CAAC,CAAC;QAEzE,OAAO,IAAI,CAAC;IACd,CAAC;CACF","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { GetTokenOptions } from \"@azure/core-auth\";\nimport {\n  AuthorizeRequestOnChallengeOptions,\n  ChallengeCallbacks,\n  AuthorizeRequestOptions,\n} from \"@azure/core-rest-pipeline\";\nimport { parseWWWAuthenticate } from \"./utils/wwwAuthenticateParser\";\nimport {\n  ContainerRegistryGetTokenOptions,\n  ContainerRegistryRefreshTokenCredential,\n} from \"./containerRegistryTokenCredential\";\nimport { AccessTokenRefresher, createTokenCycler } from \"./utils/tokenCycler\";\n\nconst fiveMinutesInMs = 5 * 60 * 1000;\n\n/**\n * Handles challenge based authentication for Container Registry Service.\n *```\n *  The challenge-based authorization flow for ACR is illustrated in the following steps.\n *  For example, GET /api/v1/acr/repositories translates into the following calls.\n *      Step 1: GET /api/v1/acr/repositories\n *  Return Header: 401: www-authenticate header - Bearer realm=\"{url}\",service=\"{serviceName}\",scope=\"{scope}\",error=\"invalid_token\"\n *      Step 2: Retrieve the serviceName, scope from the WWW-Authenticate header.  (Parse the string.)\n *      Step 3: POST /api/oauth2/exchange\n *  Request Body : { service, scope, grant-type, aadToken with ARM scope }\n *  Response Body: { acrRefreshToken }\n *      Step 4: POST /api/oauth2/token\n *  Request Body: { acrRefreshToken, scope, grant-type }\n *  Response Body: { acrAccessToken }\n *      Step 5: GET /api/v1/acr/repositories\n *  Request Header: { Bearer acrTokenAccess }\n *```\n */\nexport class ChallengeHandler implements ChallengeCallbacks {\n  private readonly cycler: AccessTokenRefresher<ContainerRegistryGetTokenOptions>;\n  constructor(\n    private credential: ContainerRegistryRefreshTokenCredential,\n    private options: GetTokenOptions & { claims?: string } = {}\n  ) {\n    this.cycler = createTokenCycler(credential, {\n      refreshWindowInMs: fiveMinutesInMs,\n    });\n  }\n\n  authorizeRequest(_options: AuthorizeRequestOptions): Promise<void> {\n    return Promise.resolve();\n  }\n\n  /**\n   * Updates  the authentication context based on the challenge.\n   */\n  async authorizeRequestOnChallenge(options: AuthorizeRequestOnChallengeOptions): Promise<boolean> {\n    // Once we're here, we've completed Step 1.\n    const challenge = options.response?.headers.get(\"WWW-Authenticate\");\n    if (!challenge) {\n      throw new Error(\"Failed to retrieve challenge from response headers\");\n    }\n    // Step 2: Parse challenge string to retrieve serviceName and scope, where scope is the ACR Scope\n    const { service, scope } = parseWWWAuthenticate(challenge);\n\n    if (!service) {\n      throw new Error(\"Failed to retrieve 'service' from challenge\");\n    }\n\n    if (!scope) {\n      throw new Error(\"Failed to retrieve 'scope' from challenge\");\n    }\n\n    // Step 3: Exchange AAD Access Token for ACR Refresh Token\n    //   For anonymous access, we send the request with grant_type=password and an empty ACR refresh token\n    //   For non-anonymous access, we get an AAD token then exchange it for an ACR fresh token\n    let grantType: \"password\" | \"refresh_token\";\n    let acrRefreshToken: string;\n    if (this.credential.isAnonymousAccess) {\n      grantType = \"password\";\n      acrRefreshToken = \"\";\n    } else {\n      grantType = \"refresh_token\";\n      acrRefreshToken = (await this.cycler.getToken(scope, { ...options, service })).token;\n    }\n\n    // Step 4: Send in acrRefreshToken and get back acrAccessToken\n    const acrAccessToken =\n      await this.credential.tokenService.ExchangeAcrRefreshTokenForAcrAccessTokenAsync(\n        acrRefreshToken,\n        service,\n        scope,\n        grantType,\n        this.options\n      );\n\n    // Step 5 - Authorize Request.  At this point we're done with AAD and using an ACR access token.\n    options.request.headers.set(\"Authorization\", `Bearer ${acrAccessToken}`);\n\n    return true;\n  }\n}\n"]}