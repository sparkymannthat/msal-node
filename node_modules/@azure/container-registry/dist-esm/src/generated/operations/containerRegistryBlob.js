/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
import * as coreClient from "@azure/core-client";
import * as Mappers from "../models/mappers";
import * as Parameters from "../models/parameters";
/** Class containing ContainerRegistryBlob operations. */
export class ContainerRegistryBlobImpl {
    /**
     * Initialize a new instance of the class ContainerRegistryBlob class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Retrieve the blob from the registry identified by digest.
     * @param name Name of the image (including the namespace)
     * @param digest Digest of a BLOB
     * @param options The options parameters.
     */
    getBlob(name, digest, options) {
        return this.client.sendOperationRequest({ name, digest, options }, getBlobOperationSpec);
    }
    /**
     * Same as GET, except only the headers are returned.
     * @param name Name of the image (including the namespace)
     * @param digest Digest of a BLOB
     * @param options The options parameters.
     */
    checkBlobExists(name, digest, options) {
        return this.client.sendOperationRequest({ name, digest, options }, checkBlobExistsOperationSpec);
    }
    /**
     * Removes an already uploaded blob.
     * @param name Name of the image (including the namespace)
     * @param digest Digest of a BLOB
     * @param options The options parameters.
     */
    deleteBlob(name, digest, options) {
        return this.client.sendOperationRequest({ name, digest, options }, deleteBlobOperationSpec);
    }
    /**
     * Mount a blob identified by the `mount` parameter from another repository.
     * @param name Name of the image (including the namespace)
     * @param mount Digest of blob to mount from the source repository.
     * @param fromParam Name of the source repository.
     * @param options The options parameters.
     */
    mountBlob(name, mount, fromParam, options) {
        return this.client.sendOperationRequest({ name, mount, fromParam, options }, mountBlobOperationSpec);
    }
    /**
     * Retrieve status of upload identified by uuid. The primary purpose of this endpoint is to resolve the
     * current status of a resumable upload.
     * @param location Link acquired from upload start or previous chunk. Note, do not include initial /
     *                 (must do substring(1) )
     * @param options The options parameters.
     */
    getUploadStatus(location, options) {
        return this.client.sendOperationRequest({ location, options }, getUploadStatusOperationSpec);
    }
    /**
     * Upload a stream of data without completing the upload.
     * @param location Link acquired from upload start or previous chunk. Note, do not include initial /
     *                 (must do substring(1) )
     * @param value Raw data of blob
     * @param options The options parameters.
     */
    uploadChunk(location, value, options) {
        return this.client.sendOperationRequest({ location, value, options }, uploadChunkOperationSpec);
    }
    /**
     * Complete the upload, providing all the data in the body, if necessary. A request without a body will
     * just complete the upload with previously uploaded content.
     * @param digest Digest of a BLOB
     * @param location Link acquired from upload start or previous chunk. Note, do not include initial /
     *                 (must do substring(1) )
     * @param options The options parameters.
     */
    completeUpload(digest, location, options) {
        return this.client.sendOperationRequest({ digest, location, options }, completeUploadOperationSpec);
    }
    /**
     * Cancel outstanding upload processes, releasing associated resources. If this is not called, the
     * unfinished uploads will eventually timeout.
     * @param location Link acquired from upload start or previous chunk. Note, do not include initial /
     *                 (must do substring(1) )
     * @param options The options parameters.
     */
    cancelUpload(location, options) {
        return this.client.sendOperationRequest({ location, options }, cancelUploadOperationSpec);
    }
    /**
     * Initiate a resumable blob upload with an empty request body.
     * @param name Name of the image (including the namespace)
     * @param options The options parameters.
     */
    startUpload(name, options) {
        return this.client.sendOperationRequest({ name, options }, startUploadOperationSpec);
    }
    /**
     * Retrieve the blob from the registry identified by `digest`. This endpoint may also support RFC7233
     * compliant range requests. Support can be detected by issuing a HEAD request. If the header
     * `Accept-Range: bytes` is returned, range requests can be used to fetch partial content.
     * @param name Name of the image (including the namespace)
     * @param digest Digest of a BLOB
     * @param range Format : bytes=<start>-<end>,  HTTP Range header specifying blob chunk.
     * @param options The options parameters.
     */
    getChunk(name, digest, range, options) {
        return this.client.sendOperationRequest({ name, digest, range, options }, getChunkOperationSpec);
    }
    /**
     * Same as GET, except only the headers are returned.
     * @param name Name of the image (including the namespace)
     * @param digest Digest of a BLOB
     * @param range Format : bytes=<start>-<end>,  HTTP Range header specifying blob chunk.
     * @param options The options parameters.
     */
    checkChunkExists(name, digest, range, options) {
        return this.client.sendOperationRequest({ name, digest, range, options }, checkChunkExistsOperationSpec);
    }
}
// Operation Specifications
const serializer = coreClient.createSerializer(Mappers, /* isXml */ false);
const getBlobOperationSpec = {
    path: "/v2/{name}/blobs/{digest}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: {
                type: { name: "Stream" },
                serializedName: "parsedResponse"
            },
            headersMapper: Mappers.ContainerRegistryBlobGetBlobHeaders
        },
        307: {
            headersMapper: Mappers.ContainerRegistryBlobGetBlobHeaders
        },
        default: {}
    },
    urlParameters: [Parameters.url, Parameters.name, Parameters.digest1],
    headerParameters: [Parameters.accept2],
    serializer
};
const checkBlobExistsOperationSpec = {
    path: "/v2/{name}/blobs/{digest}",
    httpMethod: "HEAD",
    responses: {
        200: {
            headersMapper: Mappers.ContainerRegistryBlobCheckBlobExistsHeaders
        },
        307: {
            headersMapper: Mappers.ContainerRegistryBlobCheckBlobExistsHeaders
        },
        default: {
            bodyMapper: Mappers.AcrErrors
        }
    },
    urlParameters: [Parameters.url, Parameters.name, Parameters.digest1],
    headerParameters: [Parameters.accept],
    serializer
};
const deleteBlobOperationSpec = {
    path: "/v2/{name}/blobs/{digest}",
    httpMethod: "DELETE",
    responses: {
        202: {
            bodyMapper: {
                type: { name: "Stream" },
                serializedName: "parsedResponse"
            },
            headersMapper: Mappers.ContainerRegistryBlobDeleteBlobHeaders
        },
        default: {}
    },
    urlParameters: [Parameters.url, Parameters.name, Parameters.digest1],
    headerParameters: [Parameters.accept2],
    serializer
};
const mountBlobOperationSpec = {
    path: "/v2/{name}/blobs/uploads/",
    httpMethod: "POST",
    responses: {
        201: {
            headersMapper: Mappers.ContainerRegistryBlobMountBlobHeaders
        },
        default: {
            bodyMapper: Mappers.AcrErrors
        }
    },
    queryParameters: [Parameters.fromParam, Parameters.mount],
    urlParameters: [Parameters.url, Parameters.name],
    headerParameters: [Parameters.accept],
    serializer
};
const getUploadStatusOperationSpec = {
    path: "/{nextBlobUuidLink}",
    httpMethod: "GET",
    responses: {
        204: {
            headersMapper: Mappers.ContainerRegistryBlobGetUploadStatusHeaders
        },
        default: {
            bodyMapper: Mappers.AcrErrors
        }
    },
    urlParameters: [Parameters.url, Parameters.location],
    headerParameters: [Parameters.accept],
    serializer
};
const uploadChunkOperationSpec = {
    path: "/{nextBlobUuidLink}",
    httpMethod: "PATCH",
    responses: {
        202: {
            headersMapper: Mappers.ContainerRegistryBlobUploadChunkHeaders
        },
        default: {
            bodyMapper: Mappers.AcrErrors
        }
    },
    requestBody: Parameters.value3,
    urlParameters: [Parameters.url, Parameters.location],
    headerParameters: [Parameters.contentType2, Parameters.accept3],
    mediaType: "binary",
    serializer
};
const completeUploadOperationSpec = {
    path: "/{nextBlobUuidLink}",
    httpMethod: "PUT",
    responses: {
        201: {
            headersMapper: Mappers.ContainerRegistryBlobCompleteUploadHeaders
        },
        default: {
            bodyMapper: Mappers.AcrErrors
        }
    },
    requestBody: Parameters.value4,
    queryParameters: [Parameters.digest2],
    urlParameters: [Parameters.url, Parameters.location],
    headerParameters: [Parameters.contentType2, Parameters.accept3],
    mediaType: "binary",
    serializer
};
const cancelUploadOperationSpec = {
    path: "/{nextBlobUuidLink}",
    httpMethod: "DELETE",
    responses: {
        204: {},
        default: {
            bodyMapper: Mappers.AcrErrors
        }
    },
    urlParameters: [Parameters.url, Parameters.location],
    headerParameters: [Parameters.accept],
    serializer
};
const startUploadOperationSpec = {
    path: "/v2/{name}/blobs/uploads/",
    httpMethod: "POST",
    responses: {
        202: {
            headersMapper: Mappers.ContainerRegistryBlobStartUploadHeaders
        },
        default: {
            bodyMapper: Mappers.AcrErrors
        }
    },
    urlParameters: [Parameters.url, Parameters.name],
    headerParameters: [Parameters.accept],
    serializer
};
const getChunkOperationSpec = {
    path: "/v2/{name}/blobs/{digest}",
    httpMethod: "GET",
    responses: {
        206: {
            bodyMapper: {
                type: { name: "Stream" },
                serializedName: "parsedResponse"
            },
            headersMapper: Mappers.ContainerRegistryBlobGetChunkHeaders
        },
        default: {}
    },
    urlParameters: [Parameters.url, Parameters.name, Parameters.digest1],
    headerParameters: [Parameters.accept2, Parameters.range],
    serializer
};
const checkChunkExistsOperationSpec = {
    path: "/v2/{name}/blobs/{digest}",
    httpMethod: "HEAD",
    responses: {
        200: {
            headersMapper: Mappers.ContainerRegistryBlobCheckChunkExistsHeaders
        },
        default: {
            bodyMapper: Mappers.AcrErrors
        }
    },
    urlParameters: [Parameters.url, Parameters.name, Parameters.digest1],
    headerParameters: [Parameters.accept, Parameters.range],
    serializer
};
//# sourceMappingURL=containerRegistryBlob.js.map