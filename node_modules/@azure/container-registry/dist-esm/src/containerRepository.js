// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
import { __asyncDelegator, __asyncGenerator, __asyncValues, __await } from "tslib";
import { SpanStatusCode } from "@azure/core-tracing";
import "@azure/core-paging";
import { createSpan } from "./tracing";
import { RegistryArtifactImpl } from "./registryArtifact";
import { toArtifactManifestProperties, toServiceManifestOrderBy } from "./transformations";
import { extractNextLink } from "./utils/helpers";
/**
 * The client class used to interact with the Container Registry service.
 * @internal
 */
export class ContainerRepositoryImpl {
    /**
     * Creates an instance of a ContainerRepository.
     * @param registryEndpoint - the URL to the Container Registry endpoint
     * @param name - the name of the repository
     * @param client - the generated client that interacts with service
     */
    constructor(registryEndpoint, name, client) {
        this.registryEndpoint = registryEndpoint;
        this.name = name;
        this.client = client;
    }
    /**
     * Deletes this repository and all artifacts that are part of its logical group.
     *
     * @param options - optional configuration for the operation
     */
    async delete(options = {}) {
        const { span, updatedOptions } = createSpan("ContainerRepository-delete", options);
        try {
            await this.client.containerRegistry.deleteRepository(this.name, updatedOptions);
        }
        catch (e) {
            span.setStatus({ code: SpanStatusCode.ERROR, message: e.message });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Returns an helper instance of {@link RegistryArtifact} for the given tag or digest.
     * @param tagOrDigest - the tag or digest of the artifact
     */
    getArtifact(tagOrDigest) {
        if (!tagOrDigest) {
            throw new Error("invalid tagOrDigest");
        }
        return new RegistryArtifactImpl(this.registryEndpoint, this.name, tagOrDigest, this.client);
    }
    /**
     * Retrieves the properties of this repository.
     * @param options -
     */
    async getProperties(options = {}) {
        const { span, updatedOptions } = createSpan("ContainerRepository-getProperties", options);
        try {
            return await this.client.containerRegistry.getProperties(this.name, updatedOptions);
        }
        catch (e) {
            span.setStatus({ code: SpanStatusCode.ERROR, message: e.message });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Updates the properties of this repository.
     *
     * Example usage:
     *
     * ```javascript
     * const client = new ContainerRegistryClient(url, credential);
     * const repository = client.getRepository(repositoryName)
     * const updated = await repository.updateProperties({
     *   canDelete: false,
     *   canList: false,
     *   canRead: false,
     *   canWrite: false
     * });
     * ```
     * @param options -
     */
    async updateProperties(options) {
        const value = {
            canDelete: options.canDelete,
            canWrite: options.canWrite,
            canList: options.canList,
            canRead: options.canRead,
        };
        const { span, updatedOptions } = createSpan("ContainerRepository-updateProperties", Object.assign(Object.assign({}, options), { value }));
        try {
            return await this.client.containerRegistry.updateProperties(this.name, updatedOptions);
        }
        catch (e) {
            span.setStatus({ code: SpanStatusCode.ERROR, message: e.message });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Returns an async iterable iterator to list manifest properties.
     * This is useful for determining the collection of artifacts associated with
     * this repository, as each artifact is uniquely identified by its manifest.
     *
     * Example using `for-await-of` syntax:
     *
     * ```javascript
     * const client = new ContainerRegistryClient(url, credential);
     * const repository = client.getRepository(repositoryName)
     * for await (const manifest of repository.listManifestProperties()) {
     *   console.log("manifest: ", manifest);
     * }
     * ```
     *
     * Example using `iter.next()`:
     *
     * ```javascript
     * const iter = repository.listManifestProperties();
     * let item = await iter.next();
     * while (!item.done) {
     *   console.log("manifest properties: ", item.value);
     *   item = await iter.next();
     * }
     * ```
     *
     * Example using `byPage()`:
     *
     * ```javascript
     * const pages = repository.listManifestProperties().byPage({ maxPageSize: 2 });
     * let page = await pages.next();
     * let i = 1;
     * while (!page.done) {
     *  if (page.value) {
     *    console.log(`-- page ${i++}`);
     *    for (const manifestProperties of page.value) {
     *      console.log(`  manifest properties: ${manifestProperties}`);
     *    }
     *  }
     *  page = await pages.next();
     * }
     * ```
     * @param options -
     */
    listManifestProperties(options = {}) {
        const iter = this.listManifestsItems(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings = {}) => this.listManifestsPage(settings, options),
        };
    }
    listManifestsItems(options = {}) {
        return __asyncGenerator(this, arguments, function* listManifestsItems_1() {
            var e_1, _a;
            try {
                for (var _b = __asyncValues(this.listManifestsPage({}, options)), _c; _c = yield __await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield __await(yield* __asyncDelegator(__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield __await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    listManifestsPage(continuationState, options = {}) {
        return __asyncGenerator(this, arguments, function* listManifestsPage_1() {
            const orderby = toServiceManifestOrderBy(options.order);
            if (!continuationState.continuationToken) {
                const optionsComplete = Object.assign(Object.assign({}, options), { n: continuationState.maxPageSize, orderby });
                const currentPage = yield __await(this.client.containerRegistry.getManifests(this.name, optionsComplete));
                continuationState.continuationToken = extractNextLink(currentPage.link);
                if (currentPage.manifests) {
                    const array = currentPage.manifests.map((t) => toArtifactManifestProperties(t, this.name, currentPage.registryLoginServer));
                    yield yield __await(Object.defineProperty(array, "continuationToken", {
                        value: continuationState.continuationToken,
                        enumerable: true,
                    }));
                }
            }
            while (continuationState.continuationToken) {
                const currentPage = yield __await(this.client.containerRegistry.getManifestsNext(this.name, continuationState.continuationToken, options));
                continuationState.continuationToken = extractNextLink(currentPage.link);
                if (currentPage.manifests) {
                    const array = currentPage.manifests.map((t) => toArtifactManifestProperties(t, this.name, currentPage.registryLoginServer));
                    yield yield __await(Object.defineProperty(array, "continuationToken", {
                        value: continuationState.continuationToken,
                        enumerable: true,
                    }));
                }
            }
        });
    }
}
//# sourceMappingURL=containerRepository.js.map