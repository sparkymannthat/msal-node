// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
import { __asyncDelegator, __asyncGenerator, __asyncValues, __await } from "tslib";
import { SpanStatusCode } from "@azure/core-tracing";
import "@azure/core-paging";
import { URL } from "./utils/url";
import { createSpan } from "./tracing";
import { extractNextLink, isDigest } from "./utils/helpers";
import { toArtifactManifestProperties, toServiceTagOrderBy } from "./transformations";
/**
 * The client class used to interact with the Container Registry service.
 * @internal
 */
export class RegistryArtifactImpl {
    /**
     * Creates an instance of a RegistryArtifact.
     * @param registryEndpoint - the URL to the Container Registry endpoint
     * @param repositoryName - the name of the repository
     * @param tagOrDigest - the tag or digest of this artifact
     * @param client - the generated client that interacts with service
     */
    constructor(registryEndpoint, repositoryName, tagOrDigest, client) {
        this.tagOrDigest = tagOrDigest;
        this.registryEndpoint = registryEndpoint;
        this.repositoryName = repositoryName;
        const parsedUrl = new URL(registryEndpoint);
        if (isDigest(tagOrDigest)) {
            this.digest = tagOrDigest;
            this.fullyQualifiedReference = `${parsedUrl.hostname}/${repositoryName}@${this.digest}`;
        }
        else {
            this.fullyQualifiedReference = `${parsedUrl.hostname}/${repositoryName}:${tagOrDigest}`;
        }
        this.client = client;
    }
    /**
     * digest of this artifact.
     */
    async getDigest() {
        if (this.digest) {
            return this.digest;
        }
        if (!isDigest(this.tagOrDigest)) {
            this.digest = (await this.getTagProperties(this.tagOrDigest)).digest;
        }
        else {
            this.digest = this.tagOrDigest;
        }
        return this.digest;
    }
    /**
     * Deletes this registry artifact by deleting its manifest.
     * @param options -
     */
    async delete(options = {}) {
        const { span, updatedOptions } = createSpan("RegistryArtifact-delete", options);
        try {
            await this.client.containerRegistry.deleteManifest(this.repositoryName, await this.getDigest(), updatedOptions);
        }
        catch (e) {
            span.setStatus({ code: SpanStatusCode.ERROR, message: e.message });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Deletes a tag. This removes the tag from the artifact and its manifest.
     * @param tag - the name of the tag to delete.
     * @param options -
     */
    async deleteTag(tag, options = {}) {
        if (!tag) {
            throw new Error("invalid tag");
        }
        const { span, updatedOptions } = createSpan("RegistryArtifact-deleteTag", options);
        try {
            await this.client.containerRegistry.deleteTag(this.repositoryName, tag, updatedOptions);
        }
        catch (e) {
            span.setStatus({ code: SpanStatusCode.ERROR, message: e.message });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Retrieves the properties of the manifest that uniquely identifies this artifact.
     * @param options -
     */
    async getManifestProperties(options = {}) {
        const { span, updatedOptions } = createSpan("RegistryArtifact-getManifestProperties", options);
        try {
            const result = await this.client.containerRegistry.getManifestProperties(this.repositoryName, await this.getDigest(), updatedOptions);
            return toArtifactManifestProperties(result, this.repositoryName, result.registryLoginServer);
        }
        catch (e) {
            span.setStatus({ code: SpanStatusCode.ERROR, message: e.message });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Updates the properties of the artifact's manifest.
     *
     * Example usage:
     *
     * ```javascript
     * const client = new ContainerRegistryClient(url, credential);
     * const artifact = client.getArtifact(repositoryName, artifactTagOrDigest)
     * const updated = await artifact.updateManifestProperties({
     *   canDelete: false,
     *   canList: false,
     *   canRead: false,
     *   canWrite: false
     * });
     * ```
     * @param options -
     */
    async updateManifestProperties(options) {
        const { span, updatedOptions } = createSpan("RegistryArtifact-updateManifestProperties", Object.assign(Object.assign({}, options), { value: {
                canDelete: options.canDelete,
                canWrite: options.canWrite,
                canList: options.canList,
                canRead: options.canRead,
            } }));
        try {
            const result = await this.client.containerRegistry.updateManifestProperties(this.repositoryName, await this.getDigest(), updatedOptions);
            return toArtifactManifestProperties(result, this.repositoryName, result.registryLoginServer);
        }
        catch (e) {
            span.setStatus({ code: SpanStatusCode.ERROR, message: e.message });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Retrieves the properties of the specified tag.
     * @param tag - the tag to retrieve properties.
     * @param options -
     */
    async getTagProperties(tag, options = {}) {
        if (!tag) {
            throw new Error("invalid tag");
        }
        const { span, updatedOptions } = createSpan("RegistryArtifact-getTagProperties", options);
        try {
            return await this.client.containerRegistry.getTagProperties(this.repositoryName, tag, updatedOptions);
        }
        catch (e) {
            span.setStatus({ code: SpanStatusCode.ERROR, message: e.message });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Updates the properties of a given tag.
     *
     * Example usage:
     *
     * ```javascript
     * const client = new ContainerRegistryClient(url, credential);
     * const artifact = client.getArtifact(repositoryName, artifactTagOrDigest)
     * const updated = await artifact.updateTagProperties(tag, {
     *   canDelete: false,
     *   canList: false,
     *   canRead: false,
     *   canWrite: false
     * });
     * ```
     * @param tag - name of the tag to update properties on
     * @param options -
     */
    async updateTagProperties(tag, options) {
        if (!tag) {
            throw new Error("invalid tag");
        }
        const { span, updatedOptions } = createSpan("RegistryArtifact-updateTagProperties", Object.assign(Object.assign({}, options), { value: {
                canDelete: options.canDelete,
                canWrite: options.canWrite,
                canList: options.canList,
                canRead: options.canRead,
            } }));
        try {
            return await this.client.containerRegistry.updateTagAttributes(this.repositoryName, tag, updatedOptions);
        }
        catch (e) {
            span.setStatus({ code: SpanStatusCode.ERROR, message: e.message });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Returns an async iterable iterator to list the tags that uniquely identify this artifact and the properties of each.
     *
     * Example using `for-await-of` syntax:
     *
     * ```javascript
     * const client = new ContainerRegistryClient(url, credentials);
     * const repository = client.getRepository(repositoryName);
     * const artifact = repository.getArtifact(digest)
     * for await (const tag of artifact.listTagProperties()) {
     *   console.log("tag: ", tag);
     * }
     * ```
     *
     * Example using `iter.next()`:
     *
     * ```javascript
     * const iter = artifact.listTagProperties();
     * let item = await iter.next();
     * while (!item.done) {
     *   console.log("tag properties: ", item.value);
     *   item = await iter.next();
     * }
     * ```
     *
     * Example using `byPage()`:
     *
     * ```javascript
     * const pages = artifact.listTagProperties().byPage({ maxPageSize: 2 });
     * let page = await pages.next();
     * let i = 1;
     * while (!page.done) {
     *  if (page.value) {
     *    console.log(`-- page ${i++}`);
     *    for (const tagProperties of page.value) {
     *      console.log(`  repository name: ${tagProperties}`);
     *    }
     *  }
     *  page = await pages.next();
     * }
     * ```
     * @param options -
     */
    listTagProperties(options = {}) {
        const iter = this.listTagsItems(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings = {}) => this.listTagsPage(settings, options),
        };
    }
    listTagsItems(options = {}) {
        return __asyncGenerator(this, arguments, function* listTagsItems_1() {
            var e_1, _a;
            try {
                for (var _b = __asyncValues(this.listTagsPage({}, options)), _c; _c = yield __await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield __await(yield* __asyncDelegator(__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield __await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    listTagsPage(continuationState, options = {}) {
        return __asyncGenerator(this, arguments, function* listTagsPage_1() {
            const orderby = toServiceTagOrderBy(options.order);
            if (!continuationState.continuationToken) {
                const optionsComplete = Object.assign(Object.assign({}, options), { n: continuationState.maxPageSize, orderby });
                const currentPage = yield __await(this.client.containerRegistry.getTags(this.repositoryName, optionsComplete));
                continuationState.continuationToken = extractNextLink(currentPage.link);
                if (currentPage.tagAttributeBases) {
                    const array = currentPage.tagAttributeBases.map((t) => {
                        return Object.assign({ registryLoginServer: currentPage.registryLoginServer, repositoryName: currentPage.repository }, t);
                    });
                    yield yield __await(Object.defineProperty(array, "continuationToken", {
                        value: continuationState.continuationToken,
                        enumerable: true,
                    }));
                }
            }
            while (continuationState.continuationToken) {
                const currentPage = yield __await(this.client.containerRegistry.getTagsNext(this.repositoryName, continuationState.continuationToken, options));
                continuationState.continuationToken = extractNextLink(currentPage.link);
                if (currentPage.tagAttributeBases) {
                    const array = currentPage.tagAttributeBases.map((t) => {
                        return Object.assign({ registryLoginServer: currentPage.registryLoginServer, repositoryName: currentPage.repository }, t);
                    });
                    yield yield __await(Object.defineProperty(array, "continuationToken", {
                        value: continuationState.continuationToken,
                        enumerable: true,
                    }));
                }
            }
        });
    }
}
//# sourceMappingURL=registryArtifact.js.map