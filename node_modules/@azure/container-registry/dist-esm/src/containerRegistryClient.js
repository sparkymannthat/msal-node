// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
import { __asyncDelegator, __asyncGenerator, __asyncValues, __await } from "tslib";
/// <reference lib="esnext.asynciterable" />
import { isTokenCredential } from "@azure/core-auth";
import { bearerTokenAuthenticationPolicy, } from "@azure/core-rest-pipeline";
import { SpanStatusCode } from "@azure/core-tracing";
import "@azure/core-paging";
import { logger } from "./logger";
import { GeneratedClient } from "./generated";
import { createSpan } from "./tracing";
import { extractNextLink } from "./utils/helpers";
import { ChallengeHandler } from "./containerRegistryChallengeHandler";
import { ContainerRepositoryImpl, } from "./containerRepository";
import { ContainerRegistryRefreshTokenCredential } from "./containerRegistryTokenCredential";
const LATEST_API_VERSION = "2021-07-01";
/**
 * The client class used to interact with the Container Registry service.
 */
export class ContainerRegistryClient {
    constructor(endpoint, credentialOrOptions, clientOptions = {}) {
        var _a;
        if (!endpoint) {
            throw new Error("invalid endpoint");
        }
        this.endpoint = endpoint;
        let credential;
        let options;
        if (isTokenCredential(credentialOrOptions)) {
            credential = credentialOrOptions;
            options = clientOptions;
        }
        else {
            options = credentialOrOptions !== null && credentialOrOptions !== void 0 ? credentialOrOptions : {};
        }
        const internalPipelineOptions = Object.assign(Object.assign({}, options), { loggingOptions: {
                logger: logger.info,
                // This array contains header names we want to log that are not already
                // included as safe. Unknown/unsafe headers are logged as "<REDACTED>".
                additionalAllowedQueryParameters: ["last", "n", "orderby", "digest"],
            } });
        // Require audience now until we have a default ACR audience from the service.
        if (!options.audience) {
            throw new Error("ContainerRegistryClientOptions.audience must be set to initialize ContainerRegistryClient.");
        }
        const defaultScope = `${options.audience}/.default`;
        const serviceVersion = (_a = options.serviceVersion) !== null && _a !== void 0 ? _a : LATEST_API_VERSION;
        const authClient = new GeneratedClient(endpoint, serviceVersion, internalPipelineOptions);
        this.client = new GeneratedClient(endpoint, serviceVersion, internalPipelineOptions);
        this.client.pipeline.addPolicy(bearerTokenAuthenticationPolicy({
            credential,
            scopes: [defaultScope],
            challengeCallbacks: new ChallengeHandler(new ContainerRegistryRefreshTokenCredential(authClient, defaultScope, credential)),
        }));
    }
    /**
     * Deletes the repository identified by the given name and all associated artifacts.
     *
     * @param repositoryName - the name of repository to delete
     * @param options - optional configuration for the operation
     */
    async deleteRepository(repositoryName, options = {}) {
        if (!repositoryName) {
            throw new Error("invalid repositoryName");
        }
        const { span, updatedOptions } = createSpan("ContainerRegistryClient-deleteRepository", options);
        try {
            await this.client.containerRegistry.deleteRepository(repositoryName, updatedOptions);
        }
        catch (e) {
            span.setStatus({ code: SpanStatusCode.ERROR, message: e.message });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Returns an instance of {@link RegistryArtifact} for calling service methods related to the artifact specified by `repositoryName` and `tagOrDigest`.
     *
     * @param repositoryName - the name of repository
     * @param tagOrDigest - tag or digest of the artifact to retrieve
     */
    getArtifact(repositoryName, tagOrDigest) {
        if (!repositoryName) {
            throw new Error("invalid repositoryName");
        }
        if (!tagOrDigest) {
            throw new Error("invalid tagOrDigest");
        }
        return new ContainerRepositoryImpl(this.endpoint, repositoryName, this.client).getArtifact(tagOrDigest);
    }
    /**
     * Returns an instance of {@link ContainerRepository} for calling service methods related to the repository specified by `repositoryName`.
     *
     * @param repositoryName - the name of repository
     */
    getRepository(repositoryName) {
        if (!repositoryName) {
            throw new Error("invalid repositoryName");
        }
        return new ContainerRepositoryImpl(this.endpoint, repositoryName, this.client);
    }
    /**
     * Returns an async iterable iterator to list names of repositories in this registry.
     *
     * Example usage:
     * ```javascript
     * let client = new ContainerRegistryClient(url, credential);
     * for await (const repository of client.listRepositoryNames()) {
     *   console.log("repository name: ", repository);
     * }
     * ```
     *
     * Example using `iter.next()`:
     *
     * ```javascript
     * let iter = client.listRepositoryNames();
     * let item = await iter.next();
     * while (!item.done) {
     *   console.log(`repository name: ${item.value}`);
     *   item = await iter.next();
     * }
     * ```
     *
     * Example using `byPage()`:
     *
     * ```javascript
     * const pages = client.listRepositoryNames().byPage({ maxPageSize: 2 });
     * let page = await pages.next();
     * let i = 1;
     * while (!page.done) {
     *  if (page.value) {
     *    console.log(`-- page ${i++}`);
     *    for (const name of page.value) {
     *      console.log(`  repository name: ${name}`);
     *    }
     *  }
     *  page = await pages.next();
     * }
     * ```
     * @param options -
     */
    listRepositoryNames(options = {}) {
        const iter = this.listRepositoryItems(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings = {}) => this.listRepositoriesPage(settings, options),
        };
    }
    listRepositoryItems(options = {}) {
        return __asyncGenerator(this, arguments, function* listRepositoryItems_1() {
            var e_1, _a;
            try {
                for (var _b = __asyncValues(this.listRepositoriesPage({}, options)), _c; _c = yield __await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield __await(yield* __asyncDelegator(__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield __await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    listRepositoriesPage(continuationState, options = {}) {
        return __asyncGenerator(this, arguments, function* listRepositoriesPage_1() {
            if (!continuationState.continuationToken) {
                const optionsComplete = Object.assign(Object.assign({}, options), { n: continuationState.maxPageSize });
                const currentPage = yield __await(this.client.containerRegistry.getRepositories(optionsComplete));
                continuationState.continuationToken = extractNextLink(currentPage.link);
                if (currentPage.repositories) {
                    const array = currentPage.repositories;
                    yield yield __await(Object.defineProperty(array, "continuationToken", {
                        value: continuationState.continuationToken,
                        enumerable: true,
                    }));
                }
            }
            while (continuationState.continuationToken) {
                const currentPage = yield __await(this.client.containerRegistry.getRepositoriesNext(continuationState.continuationToken, options));
                continuationState.continuationToken = extractNextLink(currentPage.link);
                if (currentPage.repositories) {
                    const array = currentPage.repositories;
                    yield yield __await(Object.defineProperty(array, "continuationToken", {
                        value: continuationState.continuationToken,
                        enumerable: true,
                    }));
                }
            }
        });
    }
}
//# sourceMappingURL=containerRegistryClient.js.map