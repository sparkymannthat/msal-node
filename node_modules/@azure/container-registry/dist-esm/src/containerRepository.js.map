{"version":3,"file":"containerRepository.js","sourceRoot":"","sources":["../../src/containerRepository.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\n/// <reference lib=\"esnext.asynciterable\" />\n\nimport { OperationOptions } from \"@azure/core-client\";\nimport { SpanStatusCode } from \"@azure/core-tracing\";\nimport \"@azure/core-paging\";\nimport { PageSettings, PagedAsyncIterableIterator } from \"@azure/core-paging\";\n\nimport { GeneratedClient, RepositoryWriteableProperties } from \"./generated\";\nimport { createSpan } from \"./tracing\";\nimport {\n  ArtifactManifestOrder,\n  ContainerRepositoryProperties,\n  ArtifactManifestProperties,\n  ManifestPageResponse,\n} from \"./models\";\nimport { RegistryArtifact, RegistryArtifactImpl } from \"./registryArtifact\";\nimport { toArtifactManifestProperties, toServiceManifestOrderBy } from \"./transformations\";\nimport { extractNextLink } from \"./utils/helpers\";\n\n/**\n * Options for delete repository operation.\n */\nexport interface DeleteRepositoryOptions extends OperationOptions {}\n/**\n * Options for the `listRegistryArtifacts` method of `ContainerRepository`.\n */\nexport interface ListManifestPropertiesOptions extends OperationOptions {\n  /** order in which the manifest properties are returned */\n  order?: ArtifactManifestOrder;\n}\n/**\n * Options for the `getProperties` method of `ContainerRepository`.\n */\nexport interface GetRepositoryPropertiesOptions extends OperationOptions {}\n/**\n * Options for the `setProperties` method of `ContainerRepository`.\n */\nexport interface UpdateRepositoryPropertiesOptions extends OperationOptions {\n  /** Whether or not this repository can be deleted */\n  canDelete?: boolean;\n  /** Whether or not this repository can be written to */\n  canWrite?: boolean;\n  /** Whether or not include this repository when listing repositories */\n  canList?: boolean;\n  /** Whether or not this repository can be read */\n  canRead?: boolean;\n}\n\n/**\n * A `repository` in a container registry is a logical grouping of images or artifacts that share the same name.  For example,\n * different versions of a `hello-world` application could have tags `v1` and `v2`, and be grouped by the repository `hello-world`.\n *\n * The {@link ContainerRepository} interface is a helper that groups information and operations about a repository in this\n * container registry.\n */\nexport interface ContainerRepository {\n  /**\n   * The Azure Container Registry endpoint.\n   */\n  readonly registryEndpoint: string;\n  /**\n   * Repository name.\n   */\n  readonly name: string;\n  /**\n   * Deletes this repository and all artifacts that are part of its logical group.\n   *\n   * @param options - optional configuration for the operation\n   */\n  delete(options?: DeleteRepositoryOptions): Promise<void>;\n  /**\n   * Returns an helper instance of {@link RegistryArtifact} for the given tag or digest.\n   * @param tagOrDigest - the tag or digest of the artifact\n   */\n  getArtifact(tagOrDigest: string): RegistryArtifact;\n  /**\n   * Retrieves the properties of this repository.\n   * @param options -\n   */\n  getProperties(options?: GetRepositoryPropertiesOptions): Promise<ContainerRepositoryProperties>;\n  /**\n   * Updates the properties of this repository.\n   *\n   * Example usage:\n   *\n   * ```javascript\n   * const client = new ContainerRegistryClient(url, credential);\n   * const repository = client.getRepository(repositoryName)\n   * const updated = await repository.updateProperties({\n   *   canDelete: false,\n   *   canList: false,\n   *   canRead: false,\n   *   canWrite: false\n   * });\n   * ```\n   * @param options -\n   */\n  updateProperties(\n    options: UpdateRepositoryPropertiesOptions\n  ): Promise<ContainerRepositoryProperties>;\n  /**\n   * Returns an async iterable iterator to list manifest properties.\n   * This is useful for determining the collection of artifacts associated with\n   * this repository, as each artifact is uniquely identified by its manifest.\n   *\n   * Example using `for-await-of` syntax:\n   *\n   * ```javascript\n   * const client = new ContainerRegistryClient(url, credential);\n   * const repository = client.getRepository(repositoryName)\n   * for await (const manifest of repository.listManifestProperties()) {\n   *   console.log(\"manifest: \", manifest);\n   * }\n   * ```\n   *\n   * Example using `iter.next()`:\n   *\n   * ```javascript\n   * const iter = repository.listManifestProperties();\n   * let item = await iter.next();\n   * while (!item.done) {\n   *   console.log(\"manifest properties: \", item.value);\n   *   item = await iter.next();\n   * }\n   * ```\n   *\n   * Example using `byPage()`:\n   *\n   * ```javascript\n   * const pages = repository.listManifestProperties().byPage({ maxPageSize: 2 });\n   * let page = await pages.next();\n   * let i = 1;\n   * while (!page.done) {\n   *  if (page.value) {\n   *    console.log(`-- page ${i++}`);\n   *    for (const manifestProperties of page.value) {\n   *      console.log(`  manifest properties: ${manifestProperties}`);\n   *    }\n   *  }\n   *  page = await pages.next();\n   * }\n   * ```\n   * @param options -\n   */\n  listManifestProperties(\n    options?: ListManifestPropertiesOptions\n  ): PagedAsyncIterableIterator<ArtifactManifestProperties>;\n}\n\n/**\n * The client class used to interact with the Container Registry service.\n * @internal\n */\nexport class ContainerRepositoryImpl {\n  private readonly client: GeneratedClient;\n  /**\n   * The Azure Container Registry endpoint.\n   */\n  public readonly registryEndpoint: string;\n  /**\n   * Repository name.\n   */\n  public readonly name: string;\n\n  /**\n   * Creates an instance of a ContainerRepository.\n   * @param registryEndpoint - the URL to the Container Registry endpoint\n   * @param name - the name of the repository\n   * @param client - the generated client that interacts with service\n   */\n  constructor(registryEndpoint: string, name: string, client: GeneratedClient) {\n    this.registryEndpoint = registryEndpoint;\n    this.name = name;\n\n    this.client = client;\n  }\n\n  /**\n   * Deletes this repository and all artifacts that are part of its logical group.\n   *\n   * @param options - optional configuration for the operation\n   */\n  public async delete(options: DeleteRepositoryOptions = {}): Promise<void> {\n    const { span, updatedOptions } = createSpan(\"ContainerRepository-delete\", options);\n\n    try {\n      await this.client.containerRegistry.deleteRepository(this.name, updatedOptions);\n    } catch (e) {\n      span.setStatus({ code: SpanStatusCode.ERROR, message: e.message });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Returns an helper instance of {@link RegistryArtifact} for the given tag or digest.\n   * @param tagOrDigest - the tag or digest of the artifact\n   */\n  public getArtifact(tagOrDigest: string): RegistryArtifact {\n    if (!tagOrDigest) {\n      throw new Error(\"invalid tagOrDigest\");\n    }\n    return new RegistryArtifactImpl(this.registryEndpoint, this.name, tagOrDigest, this.client);\n  }\n\n  /**\n   * Retrieves the properties of this repository.\n   * @param options -\n   */\n  public async getProperties(\n    options: GetRepositoryPropertiesOptions = {}\n  ): Promise<ContainerRepositoryProperties> {\n    const { span, updatedOptions } = createSpan(\"ContainerRepository-getProperties\", options);\n\n    try {\n      return await this.client.containerRegistry.getProperties(this.name, updatedOptions);\n    } catch (e) {\n      span.setStatus({ code: SpanStatusCode.ERROR, message: e.message });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Updates the properties of this repository.\n   *\n   * Example usage:\n   *\n   * ```javascript\n   * const client = new ContainerRegistryClient(url, credential);\n   * const repository = client.getRepository(repositoryName)\n   * const updated = await repository.updateProperties({\n   *   canDelete: false,\n   *   canList: false,\n   *   canRead: false,\n   *   canWrite: false\n   * });\n   * ```\n   * @param options -\n   */\n  public async updateProperties(\n    options: UpdateRepositoryPropertiesOptions\n  ): Promise<ContainerRepositoryProperties> {\n    const value: RepositoryWriteableProperties = {\n      canDelete: options.canDelete,\n      canWrite: options.canWrite,\n      canList: options.canList,\n      canRead: options.canRead,\n    };\n    const { span, updatedOptions } = createSpan(\"ContainerRepository-updateProperties\", {\n      ...options,\n      value,\n    });\n\n    try {\n      return await this.client.containerRegistry.updateProperties(this.name, updatedOptions);\n    } catch (e) {\n      span.setStatus({ code: SpanStatusCode.ERROR, message: e.message });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Returns an async iterable iterator to list manifest properties.\n   * This is useful for determining the collection of artifacts associated with\n   * this repository, as each artifact is uniquely identified by its manifest.\n   *\n   * Example using `for-await-of` syntax:\n   *\n   * ```javascript\n   * const client = new ContainerRegistryClient(url, credential);\n   * const repository = client.getRepository(repositoryName)\n   * for await (const manifest of repository.listManifestProperties()) {\n   *   console.log(\"manifest: \", manifest);\n   * }\n   * ```\n   *\n   * Example using `iter.next()`:\n   *\n   * ```javascript\n   * const iter = repository.listManifestProperties();\n   * let item = await iter.next();\n   * while (!item.done) {\n   *   console.log(\"manifest properties: \", item.value);\n   *   item = await iter.next();\n   * }\n   * ```\n   *\n   * Example using `byPage()`:\n   *\n   * ```javascript\n   * const pages = repository.listManifestProperties().byPage({ maxPageSize: 2 });\n   * let page = await pages.next();\n   * let i = 1;\n   * while (!page.done) {\n   *  if (page.value) {\n   *    console.log(`-- page ${i++}`);\n   *    for (const manifestProperties of page.value) {\n   *      console.log(`  manifest properties: ${manifestProperties}`);\n   *    }\n   *  }\n   *  page = await pages.next();\n   * }\n   * ```\n   * @param options -\n   */\n  public listManifestProperties(\n    options: ListManifestPropertiesOptions = {}\n  ): PagedAsyncIterableIterator<ArtifactManifestProperties, ManifestPageResponse> {\n    const iter = this.listManifestsItems(options);\n\n    return {\n      next() {\n        return iter.next();\n      },\n      [Symbol.asyncIterator]() {\n        return this;\n      },\n      byPage: (settings: PageSettings = {}) => this.listManifestsPage(settings, options),\n    };\n  }\n\n  private async *listManifestsItems(\n    options: ListManifestPropertiesOptions = {}\n  ): AsyncIterableIterator<ArtifactManifestProperties> {\n    for await (const page of this.listManifestsPage({}, options)) {\n      yield* page;\n    }\n  }\n\n  private async *listManifestsPage(\n    continuationState: PageSettings,\n    options: ListManifestPropertiesOptions = {}\n  ): AsyncIterableIterator<ManifestPageResponse> {\n    const orderby = toServiceManifestOrderBy(options.order);\n    if (!continuationState.continuationToken) {\n      const optionsComplete = {\n        ...options,\n        n: continuationState.maxPageSize,\n        orderby,\n      };\n      const currentPage = await this.client.containerRegistry.getManifests(\n        this.name,\n        optionsComplete\n      );\n      continuationState.continuationToken = extractNextLink(currentPage.link);\n      if (currentPage.manifests) {\n        const array = currentPage.manifests.map((t) =>\n          toArtifactManifestProperties(t, this.name, currentPage.registryLoginServer!)\n        );\n        yield Object.defineProperty(array, \"continuationToken\", {\n          value: continuationState.continuationToken,\n          enumerable: true,\n        });\n      }\n    }\n    while (continuationState.continuationToken) {\n      const currentPage = await this.client.containerRegistry.getManifestsNext(\n        this.name,\n        continuationState.continuationToken,\n        options\n      );\n      continuationState.continuationToken = extractNextLink(currentPage.link);\n      if (currentPage.manifests) {\n        const array = currentPage.manifests.map((t) =>\n          toArtifactManifestProperties(t, this.name, currentPage.registryLoginServer!)\n        );\n        yield Object.defineProperty(array, \"continuationToken\", {\n          value: continuationState.continuationToken,\n          enumerable: true,\n        });\n      }\n    }\n  }\n}\n"]}