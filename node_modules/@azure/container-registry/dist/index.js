'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var tslib = require('tslib');
var coreAuth = require('@azure/core-auth');
var coreRestPipeline = require('@azure/core-rest-pipeline');
var coreTracing = require('@azure/core-tracing');
require('@azure/core-paging');
var logger$1 = require('@azure/logger');
var coreClient = require('@azure/core-client');
var url$1 = require('url');

// Copyright (c) Microsoft Corporation.
/**
 * The \@azure/logger configuration for this package.
 *
 * @internal
 */
const logger = logger$1.createClientLogger("container-registry");

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const AcrErrors = {
    type: {
        name: "Composite",
        className: "AcrErrors",
        modelProperties: {
            errors: {
                serializedName: "errors",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AcrErrorInfo"
                        }
                    }
                }
            }
        }
    }
};
const AcrErrorInfo = {
    type: {
        name: "Composite",
        className: "AcrErrorInfo",
        modelProperties: {
            code: {
                serializedName: "code",
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                type: {
                    name: "String"
                }
            },
            detail: {
                serializedName: "detail",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            }
        }
    }
};
const Manifest = {
    type: {
        name: "Composite",
        className: "Manifest",
        modelProperties: {
            schemaVersion: {
                serializedName: "schemaVersion",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const ManifestListAttributes = {
    type: {
        name: "Composite",
        className: "ManifestListAttributes",
        modelProperties: {
            mediaType: {
                serializedName: "mediaType",
                type: {
                    name: "String"
                }
            },
            size: {
                serializedName: "size",
                type: {
                    name: "Number"
                }
            },
            digest: {
                serializedName: "digest",
                type: {
                    name: "String"
                }
            },
            platform: {
                serializedName: "platform",
                type: {
                    name: "Composite",
                    className: "Platform"
                }
            }
        }
    }
};
const Platform = {
    type: {
        name: "Composite",
        className: "Platform",
        modelProperties: {
            architecture: {
                serializedName: "architecture",
                type: {
                    name: "String"
                }
            },
            os: {
                serializedName: "os",
                type: {
                    name: "String"
                }
            },
            osVersion: {
                serializedName: "os\\.version",
                type: {
                    name: "String"
                }
            },
            osFeatures: {
                serializedName: "os\\.features",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            variant: {
                serializedName: "variant",
                type: {
                    name: "String"
                }
            },
            features: {
                serializedName: "features",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const Descriptor = {
    type: {
        name: "Composite",
        className: "Descriptor",
        modelProperties: {
            mediaType: {
                serializedName: "mediaType",
                type: {
                    name: "String"
                }
            },
            size: {
                serializedName: "size",
                type: {
                    name: "Number"
                }
            },
            digest: {
                serializedName: "digest",
                type: {
                    name: "String"
                }
            },
            urls: {
                serializedName: "urls",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            annotations: {
                serializedName: "annotations",
                type: {
                    name: "Composite",
                    className: "Annotations"
                }
            }
        }
    }
};
const Annotations = {
    type: {
        name: "Composite",
        className: "Annotations",
        additionalProperties: { type: { name: "Object" } },
        modelProperties: {
            created: {
                serializedName: "org\\.opencontainers.image.created",
                type: {
                    name: "DateTime"
                }
            },
            authors: {
                serializedName: "org\\.opencontainers.image.authors",
                type: {
                    name: "String"
                }
            },
            url: {
                serializedName: "org\\.opencontainers.image.url",
                type: {
                    name: "String"
                }
            },
            documentation: {
                serializedName: "org\\.opencontainers.image.documentation",
                type: {
                    name: "String"
                }
            },
            source: {
                serializedName: "org\\.opencontainers.image.source",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "org\\.opencontainers.image.version",
                type: {
                    name: "String"
                }
            },
            revision: {
                serializedName: "org\\.opencontainers.image.revision",
                type: {
                    name: "String"
                }
            },
            vendor: {
                serializedName: "org\\.opencontainers.image.vendor",
                type: {
                    name: "String"
                }
            },
            licenses: {
                serializedName: "org\\.opencontainers.image.licenses",
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "org\\.opencontainers.image.ref.name",
                type: {
                    name: "String"
                }
            },
            title: {
                serializedName: "org\\.opencontainers.image.title",
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "org\\.opencontainers.image.description",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const FsLayer = {
    type: {
        name: "Composite",
        className: "FsLayer",
        modelProperties: {
            blobSum: {
                serializedName: "blobSum",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const History = {
    type: {
        name: "Composite",
        className: "History",
        modelProperties: {
            v1Compatibility: {
                serializedName: "v1Compatibility",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ImageSignature = {
    type: {
        name: "Composite",
        className: "ImageSignature",
        modelProperties: {
            header: {
                serializedName: "header",
                type: {
                    name: "Composite",
                    className: "Jwk"
                }
            },
            signature: {
                serializedName: "signature",
                type: {
                    name: "String"
                }
            },
            protected: {
                serializedName: "protected",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Jwk = {
    type: {
        name: "Composite",
        className: "Jwk",
        modelProperties: {
            jwk: {
                serializedName: "jwk",
                type: {
                    name: "Composite",
                    className: "JWKHeader"
                }
            },
            alg: {
                serializedName: "alg",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const JWKHeader = {
    type: {
        name: "Composite",
        className: "JWKHeader",
        modelProperties: {
            crv: {
                serializedName: "crv",
                type: {
                    name: "String"
                }
            },
            kid: {
                serializedName: "kid",
                type: {
                    name: "String"
                }
            },
            kty: {
                serializedName: "kty",
                type: {
                    name: "String"
                }
            },
            x: {
                serializedName: "x",
                type: {
                    name: "String"
                }
            },
            y: {
                serializedName: "y",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Repositories = {
    type: {
        name: "Composite",
        className: "Repositories",
        modelProperties: {
            repositories: {
                serializedName: "repositories",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            link: {
                serializedName: "link",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ContainerRepositoryProperties = {
    type: {
        name: "Composite",
        className: "ContainerRepositoryProperties",
        modelProperties: {
            registryLoginServer: {
                serializedName: "registry",
                required: true,
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "imageName",
                required: true,
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            createdOn: {
                serializedName: "createdTime",
                required: true,
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            lastUpdatedOn: {
                serializedName: "lastUpdateTime",
                required: true,
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            manifestCount: {
                serializedName: "manifestCount",
                required: true,
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            tagCount: {
                serializedName: "tagCount",
                required: true,
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            canDelete: {
                serializedName: "changeableAttributes.deleteEnabled",
                type: {
                    name: "Boolean"
                }
            },
            canWrite: {
                serializedName: "changeableAttributes.writeEnabled",
                type: {
                    name: "Boolean"
                }
            },
            canList: {
                serializedName: "changeableAttributes.listEnabled",
                type: {
                    name: "Boolean"
                }
            },
            canRead: {
                serializedName: "changeableAttributes.readEnabled",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const RepositoryWriteableProperties = {
    type: {
        name: "Composite",
        className: "RepositoryWriteableProperties",
        modelProperties: {
            canDelete: {
                serializedName: "deleteEnabled",
                type: {
                    name: "Boolean"
                }
            },
            canWrite: {
                serializedName: "writeEnabled",
                type: {
                    name: "Boolean"
                }
            },
            canList: {
                serializedName: "listEnabled",
                type: {
                    name: "Boolean"
                }
            },
            canRead: {
                serializedName: "readEnabled",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const TagList = {
    type: {
        name: "Composite",
        className: "TagList",
        modelProperties: {
            registryLoginServer: {
                serializedName: "registry",
                required: true,
                type: {
                    name: "String"
                }
            },
            repository: {
                serializedName: "imageName",
                required: true,
                type: {
                    name: "String"
                }
            },
            tagAttributeBases: {
                serializedName: "tags",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TagAttributesBase"
                        }
                    }
                }
            },
            link: {
                serializedName: "link",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TagAttributesBase = {
    type: {
        name: "Composite",
        className: "TagAttributesBase",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            digest: {
                serializedName: "digest",
                required: true,
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            createdOn: {
                serializedName: "createdTime",
                required: true,
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            lastUpdatedOn: {
                serializedName: "lastUpdateTime",
                required: true,
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            canDelete: {
                serializedName: "changeableAttributes.deleteEnabled",
                type: {
                    name: "Boolean"
                }
            },
            canWrite: {
                serializedName: "changeableAttributes.writeEnabled",
                type: {
                    name: "Boolean"
                }
            },
            canList: {
                serializedName: "changeableAttributes.listEnabled",
                type: {
                    name: "Boolean"
                }
            },
            canRead: {
                serializedName: "changeableAttributes.readEnabled",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const TagWriteableProperties = {
    type: {
        name: "Composite",
        className: "TagWriteableProperties",
        modelProperties: {
            canDelete: {
                serializedName: "deleteEnabled",
                type: {
                    name: "Boolean"
                }
            },
            canWrite: {
                serializedName: "writeEnabled",
                type: {
                    name: "Boolean"
                }
            },
            canList: {
                serializedName: "listEnabled",
                type: {
                    name: "Boolean"
                }
            },
            canRead: {
                serializedName: "readEnabled",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const ArtifactTagProperties = {
    type: {
        name: "Composite",
        className: "ArtifactTagProperties",
        modelProperties: {
            registryLoginServer: {
                serializedName: "registry",
                required: true,
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            repositoryName: {
                serializedName: "imageName",
                required: true,
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "tag.name",
                required: true,
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            digest: {
                serializedName: "tag.digest",
                required: true,
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            createdOn: {
                serializedName: "tag.createdTime",
                required: true,
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            lastUpdatedOn: {
                serializedName: "tag.lastUpdateTime",
                required: true,
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            canDelete: {
                serializedName: "tag.changeableAttributes.deleteEnabled",
                type: {
                    name: "Boolean"
                }
            },
            canWrite: {
                serializedName: "tag.changeableAttributes.writeEnabled",
                type: {
                    name: "Boolean"
                }
            },
            canList: {
                serializedName: "tag.changeableAttributes.listEnabled",
                type: {
                    name: "Boolean"
                }
            },
            canRead: {
                serializedName: "tag.changeableAttributes.readEnabled",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const AcrManifests = {
    type: {
        name: "Composite",
        className: "AcrManifests",
        modelProperties: {
            registryLoginServer: {
                serializedName: "registry",
                type: {
                    name: "String"
                }
            },
            repository: {
                serializedName: "imageName",
                type: {
                    name: "String"
                }
            },
            manifests: {
                serializedName: "manifests",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ManifestAttributesBase"
                        }
                    }
                }
            },
            link: {
                serializedName: "link",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ManifestAttributesBase = {
    type: {
        name: "Composite",
        className: "ManifestAttributesBase",
        modelProperties: {
            digest: {
                serializedName: "digest",
                required: true,
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            size: {
                serializedName: "imageSize",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            createdOn: {
                serializedName: "createdTime",
                required: true,
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            lastUpdatedOn: {
                serializedName: "lastUpdateTime",
                required: true,
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            architecture: {
                serializedName: "architecture",
                readOnly: true,
                nullable: true,
                type: {
                    name: "String"
                }
            },
            operatingSystem: {
                serializedName: "os",
                readOnly: true,
                nullable: true,
                type: {
                    name: "String"
                }
            },
            relatedArtifacts: {
                serializedName: "references",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ArtifactManifestPlatform"
                        }
                    }
                }
            },
            tags: {
                serializedName: "tags",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            canDelete: {
                serializedName: "changeableAttributes.deleteEnabled",
                type: {
                    name: "Boolean"
                }
            },
            canWrite: {
                serializedName: "changeableAttributes.writeEnabled",
                type: {
                    name: "Boolean"
                }
            },
            canList: {
                serializedName: "changeableAttributes.listEnabled",
                type: {
                    name: "Boolean"
                }
            },
            canRead: {
                serializedName: "changeableAttributes.readEnabled",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const ArtifactManifestPlatform = {
    type: {
        name: "Composite",
        className: "ArtifactManifestPlatform",
        modelProperties: {
            digest: {
                serializedName: "digest",
                required: true,
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            architecture: {
                serializedName: "architecture",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            operatingSystem: {
                serializedName: "os",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ManifestWriteableProperties = {
    type: {
        name: "Composite",
        className: "ManifestWriteableProperties",
        modelProperties: {
            canDelete: {
                serializedName: "deleteEnabled",
                type: {
                    name: "Boolean"
                }
            },
            canWrite: {
                serializedName: "writeEnabled",
                type: {
                    name: "Boolean"
                }
            },
            canList: {
                serializedName: "listEnabled",
                type: {
                    name: "Boolean"
                }
            },
            canRead: {
                serializedName: "readEnabled",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const ArtifactManifestProperties = {
    type: {
        name: "Composite",
        className: "ArtifactManifestProperties",
        modelProperties: {
            registryLoginServer: {
                serializedName: "registry",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            repositoryName: {
                serializedName: "imageName",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            digest: {
                serializedName: "manifest.digest",
                required: true,
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            size: {
                serializedName: "manifest.imageSize",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            createdOn: {
                serializedName: "manifest.createdTime",
                required: true,
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            lastUpdatedOn: {
                serializedName: "manifest.lastUpdateTime",
                required: true,
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            architecture: {
                serializedName: "manifest.architecture",
                readOnly: true,
                nullable: true,
                type: {
                    name: "String"
                }
            },
            operatingSystem: {
                serializedName: "manifest.os",
                readOnly: true,
                nullable: true,
                type: {
                    name: "String"
                }
            },
            relatedArtifacts: {
                serializedName: "manifest.references",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ArtifactManifestPlatform"
                        }
                    }
                }
            },
            tags: {
                serializedName: "manifest.tags",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            canDelete: {
                serializedName: "manifest.changeableAttributes.deleteEnabled",
                type: {
                    name: "Boolean"
                }
            },
            canWrite: {
                serializedName: "manifest.changeableAttributes.writeEnabled",
                type: {
                    name: "Boolean"
                }
            },
            canList: {
                serializedName: "manifest.changeableAttributes.listEnabled",
                type: {
                    name: "Boolean"
                }
            },
            canRead: {
                serializedName: "manifest.changeableAttributes.readEnabled",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const AcrRefreshToken = {
    type: {
        name: "Composite",
        className: "AcrRefreshToken",
        modelProperties: {
            refreshToken: {
                serializedName: "refresh_token",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AcrAccessToken = {
    type: {
        name: "Composite",
        className: "AcrAccessToken",
        modelProperties: {
            accessToken: {
                serializedName: "access_token",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RepositoryTags = {
    type: {
        name: "Composite",
        className: "RepositoryTags",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const DeleteRepositoryResult = {
    type: {
        name: "Composite",
        className: "DeleteRepositoryResult",
        modelProperties: {
            deletedManifests: {
                serializedName: "manifestsDeleted",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            deletedTags: {
                serializedName: "tagsDeleted",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const TagAttributesTag = {
    type: {
        name: "Composite",
        className: "TagAttributesTag",
        modelProperties: {
            signatureRecord: {
                serializedName: "signatureRecord",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ManifestAttributesManifest = {
    type: {
        name: "Composite",
        className: "ManifestAttributesManifest",
        modelProperties: {
            references: {
                serializedName: "references",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ArtifactManifestPlatform"
                        }
                    }
                }
            }
        }
    }
};
const Paths108HwamOauth2ExchangePostRequestbodyContentApplicationXWwwFormUrlencodedSchema = {
    type: {
        name: "Composite",
        className: "Paths108HwamOauth2ExchangePostRequestbodyContentApplicationXWwwFormUrlencodedSchema",
        modelProperties: {
            grantType: {
                serializedName: "grant_type",
                required: true,
                type: {
                    name: "String"
                }
            },
            service: {
                serializedName: "service",
                required: true,
                type: {
                    name: "String"
                }
            },
            tenant: {
                serializedName: "tenant",
                type: {
                    name: "String"
                }
            },
            refreshToken: {
                serializedName: "refresh_token",
                type: {
                    name: "String"
                }
            },
            aadAccessToken: {
                serializedName: "access_token",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PathsV3R3RxOauth2TokenPostRequestbodyContentApplicationXWwwFormUrlencodedSchema = {
    type: {
        name: "Composite",
        className: "PathsV3R3RxOauth2TokenPostRequestbodyContentApplicationXWwwFormUrlencodedSchema",
        modelProperties: {
            service: {
                serializedName: "service",
                required: true,
                type: {
                    name: "String"
                }
            },
            scope: {
                serializedName: "scope",
                required: true,
                type: {
                    name: "String"
                }
            },
            acrRefreshToken: {
                serializedName: "refresh_token",
                required: true,
                type: {
                    name: "String"
                }
            },
            grantType: {
                serializedName: "grant_type",
                required: true,
                type: {
                    name: "Enum",
                    allowedValues: ["refresh_token", "password"]
                }
            }
        }
    }
};
const ManifestWrapper = {
    type: {
        name: "Composite",
        className: "ManifestWrapper",
        modelProperties: Object.assign(Object.assign({}, Manifest.type.modelProperties), { mediaType: {
                serializedName: "mediaType",
                type: {
                    name: "String"
                }
            }, manifests: {
                serializedName: "manifests",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ManifestListAttributes"
                        }
                    }
                }
            }, config: {
                serializedName: "config",
                type: {
                    name: "Composite",
                    className: "Descriptor"
                }
            }, layers: {
                serializedName: "layers",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Descriptor"
                        }
                    }
                }
            }, annotations: {
                serializedName: "annotations",
                type: {
                    name: "Composite",
                    className: "Annotations"
                }
            }, architecture: {
                serializedName: "architecture",
                type: {
                    name: "String"
                }
            }, name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, tag: {
                serializedName: "tag",
                type: {
                    name: "String"
                }
            }, fsLayers: {
                serializedName: "fsLayers",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "FsLayer"
                        }
                    }
                }
            }, history: {
                serializedName: "history",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "History"
                        }
                    }
                }
            }, signatures: {
                serializedName: "signatures",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ImageSignature"
                        }
                    }
                }
            } })
    }
};
const ManifestList = {
    serializedName: "application/vnd.docker.distribution.manifest.list.v2+json",
    type: {
        name: "Composite",
        className: "ManifestList",
        modelProperties: Object.assign(Object.assign({}, Manifest.type.modelProperties), { mediaType: {
                serializedName: "mediaType",
                type: {
                    name: "String"
                }
            }, manifests: {
                serializedName: "manifests",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ManifestListAttributes"
                        }
                    }
                }
            } })
    }
};
const V2Manifest = {
    serializedName: "application/vnd.docker.distribution.manifest.v2+json",
    type: {
        name: "Composite",
        className: "V2Manifest",
        modelProperties: Object.assign(Object.assign({}, Manifest.type.modelProperties), { mediaType: {
                serializedName: "mediaType",
                type: {
                    name: "String"
                }
            }, config: {
                serializedName: "config",
                type: {
                    name: "Composite",
                    className: "Descriptor"
                }
            }, layers: {
                serializedName: "layers",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Descriptor"
                        }
                    }
                }
            } })
    }
};
const OCIManifest = {
    serializedName: "application/vnd.oci.image.manifest.v1+json",
    type: {
        name: "Composite",
        className: "OCIManifest",
        modelProperties: Object.assign(Object.assign({}, Manifest.type.modelProperties), { config: {
                serializedName: "config",
                type: {
                    name: "Composite",
                    className: "Descriptor"
                }
            }, layers: {
                serializedName: "layers",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Descriptor"
                        }
                    }
                }
            }, annotations: {
                serializedName: "annotations",
                type: {
                    name: "Composite",
                    className: "Annotations"
                }
            } })
    }
};
const OCIIndex = {
    serializedName: "application/vnd.oci.image.index.v1+json",
    type: {
        name: "Composite",
        className: "OCIIndex",
        modelProperties: Object.assign(Object.assign({}, Manifest.type.modelProperties), { manifests: {
                serializedName: "manifests",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ManifestListAttributes"
                        }
                    }
                }
            }, annotations: {
                serializedName: "annotations",
                type: {
                    name: "Composite",
                    className: "Annotations"
                }
            } })
    }
};
const V1Manifest = {
    serializedName: "application/vnd.oci.image.manifest.v1+json",
    type: {
        name: "Composite",
        className: "V1Manifest",
        modelProperties: Object.assign(Object.assign({}, Manifest.type.modelProperties), { architecture: {
                serializedName: "architecture",
                type: {
                    name: "String"
                }
            }, name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, tag: {
                serializedName: "tag",
                type: {
                    name: "String"
                }
            }, fsLayers: {
                serializedName: "fsLayers",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "FsLayer"
                        }
                    }
                }
            }, history: {
                serializedName: "history",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "History"
                        }
                    }
                }
            }, signatures: {
                serializedName: "signatures",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ImageSignature"
                        }
                    }
                }
            } })
    }
};
const ContainerRegistryCreateManifestHeaders = {
    type: {
        name: "Composite",
        className: "ContainerRegistryCreateManifestHeaders",
        modelProperties: {
            dockerContentDigest: {
                serializedName: "docker-content-digest",
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            contentLength: {
                serializedName: "content-length",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const ContainerRegistryGetRepositoriesHeaders = {
    type: {
        name: "Composite",
        className: "ContainerRegistryGetRepositoriesHeaders",
        modelProperties: {
            link: {
                serializedName: "link",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ContainerRegistryGetTagsHeaders = {
    type: {
        name: "Composite",
        className: "ContainerRegistryGetTagsHeaders",
        modelProperties: {
            link: {
                serializedName: "link",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ContainerRegistryGetManifestsHeaders = {
    type: {
        name: "Composite",
        className: "ContainerRegistryGetManifestsHeaders",
        modelProperties: {
            link: {
                serializedName: "link",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ContainerRegistryGetRepositoriesNextHeaders = {
    type: {
        name: "Composite",
        className: "ContainerRegistryGetRepositoriesNextHeaders",
        modelProperties: {
            link: {
                serializedName: "link",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ContainerRegistryGetTagsNextHeaders = {
    type: {
        name: "Composite",
        className: "ContainerRegistryGetTagsNextHeaders",
        modelProperties: {
            link: {
                serializedName: "link",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ContainerRegistryGetManifestsNextHeaders = {
    type: {
        name: "Composite",
        className: "ContainerRegistryGetManifestsNextHeaders",
        modelProperties: {
            link: {
                serializedName: "link",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ContainerRegistryBlobGetBlobHeaders = {
    type: {
        name: "Composite",
        className: "ContainerRegistryBlobGetBlobHeaders",
        modelProperties: {
            contentLength: {
                serializedName: "content-length",
                type: {
                    name: "Number"
                }
            },
            dockerContentDigest: {
                serializedName: "docker-content-digest",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ContainerRegistryBlobCheckBlobExistsHeaders = {
    type: {
        name: "Composite",
        className: "ContainerRegistryBlobCheckBlobExistsHeaders",
        modelProperties: {
            contentLength: {
                serializedName: "content-length",
                type: {
                    name: "Number"
                }
            },
            dockerContentDigest: {
                serializedName: "docker-content-digest",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ContainerRegistryBlobDeleteBlobHeaders = {
    type: {
        name: "Composite",
        className: "ContainerRegistryBlobDeleteBlobHeaders",
        modelProperties: {
            dockerContentDigest: {
                serializedName: "docker-content-digest",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ContainerRegistryBlobMountBlobHeaders = {
    type: {
        name: "Composite",
        className: "ContainerRegistryBlobMountBlobHeaders",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            dockerUploadUuid: {
                serializedName: "docker-upload-uuid",
                type: {
                    name: "String"
                }
            },
            dockerContentDigest: {
                serializedName: "docker-content-digest",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ContainerRegistryBlobGetUploadStatusHeaders = {
    type: {
        name: "Composite",
        className: "ContainerRegistryBlobGetUploadStatusHeaders",
        modelProperties: {
            range: {
                serializedName: "range",
                type: {
                    name: "String"
                }
            },
            dockerUploadUuid: {
                serializedName: "docker-upload-uuid",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ContainerRegistryBlobUploadChunkHeaders = {
    type: {
        name: "Composite",
        className: "ContainerRegistryBlobUploadChunkHeaders",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            range: {
                serializedName: "range",
                type: {
                    name: "String"
                }
            },
            dockerUploadUuid: {
                serializedName: "docker-upload-uuid",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ContainerRegistryBlobCompleteUploadHeaders = {
    type: {
        name: "Composite",
        className: "ContainerRegistryBlobCompleteUploadHeaders",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            range: {
                serializedName: "range",
                type: {
                    name: "String"
                }
            },
            dockerContentDigest: {
                serializedName: "docker-content-digest",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ContainerRegistryBlobStartUploadHeaders = {
    type: {
        name: "Composite",
        className: "ContainerRegistryBlobStartUploadHeaders",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            range: {
                serializedName: "range",
                type: {
                    name: "String"
                }
            },
            dockerUploadUuid: {
                serializedName: "docker-upload-uuid",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ContainerRegistryBlobGetChunkHeaders = {
    type: {
        name: "Composite",
        className: "ContainerRegistryBlobGetChunkHeaders",
        modelProperties: {
            contentLength: {
                serializedName: "content-length",
                type: {
                    name: "Number"
                }
            },
            contentRange: {
                serializedName: "content-range",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ContainerRegistryBlobCheckChunkExistsHeaders = {
    type: {
        name: "Composite",
        className: "ContainerRegistryBlobCheckChunkExistsHeaders",
        modelProperties: {
            contentLength: {
                serializedName: "content-length",
                type: {
                    name: "Number"
                }
            },
            contentRange: {
                serializedName: "content-range",
                type: {
                    name: "String"
                }
            }
        }
    }
};

var Mappers = /*#__PURE__*/Object.freeze({
    __proto__: null,
    AcrErrors: AcrErrors,
    AcrErrorInfo: AcrErrorInfo,
    Manifest: Manifest,
    ManifestListAttributes: ManifestListAttributes,
    Platform: Platform,
    Descriptor: Descriptor,
    Annotations: Annotations,
    FsLayer: FsLayer,
    History: History,
    ImageSignature: ImageSignature,
    Jwk: Jwk,
    JWKHeader: JWKHeader,
    Repositories: Repositories,
    ContainerRepositoryProperties: ContainerRepositoryProperties,
    RepositoryWriteableProperties: RepositoryWriteableProperties,
    TagList: TagList,
    TagAttributesBase: TagAttributesBase,
    TagWriteableProperties: TagWriteableProperties,
    ArtifactTagProperties: ArtifactTagProperties,
    AcrManifests: AcrManifests,
    ManifestAttributesBase: ManifestAttributesBase,
    ArtifactManifestPlatform: ArtifactManifestPlatform,
    ManifestWriteableProperties: ManifestWriteableProperties,
    ArtifactManifestProperties: ArtifactManifestProperties,
    AcrRefreshToken: AcrRefreshToken,
    AcrAccessToken: AcrAccessToken,
    RepositoryTags: RepositoryTags,
    DeleteRepositoryResult: DeleteRepositoryResult,
    TagAttributesTag: TagAttributesTag,
    ManifestAttributesManifest: ManifestAttributesManifest,
    Paths108HwamOauth2ExchangePostRequestbodyContentApplicationXWwwFormUrlencodedSchema: Paths108HwamOauth2ExchangePostRequestbodyContentApplicationXWwwFormUrlencodedSchema,
    PathsV3R3RxOauth2TokenPostRequestbodyContentApplicationXWwwFormUrlencodedSchema: PathsV3R3RxOauth2TokenPostRequestbodyContentApplicationXWwwFormUrlencodedSchema,
    ManifestWrapper: ManifestWrapper,
    ManifestList: ManifestList,
    V2Manifest: V2Manifest,
    OCIManifest: OCIManifest,
    OCIIndex: OCIIndex,
    V1Manifest: V1Manifest,
    ContainerRegistryCreateManifestHeaders: ContainerRegistryCreateManifestHeaders,
    ContainerRegistryGetRepositoriesHeaders: ContainerRegistryGetRepositoriesHeaders,
    ContainerRegistryGetTagsHeaders: ContainerRegistryGetTagsHeaders,
    ContainerRegistryGetManifestsHeaders: ContainerRegistryGetManifestsHeaders,
    ContainerRegistryGetRepositoriesNextHeaders: ContainerRegistryGetRepositoriesNextHeaders,
    ContainerRegistryGetTagsNextHeaders: ContainerRegistryGetTagsNextHeaders,
    ContainerRegistryGetManifestsNextHeaders: ContainerRegistryGetManifestsNextHeaders,
    ContainerRegistryBlobGetBlobHeaders: ContainerRegistryBlobGetBlobHeaders,
    ContainerRegistryBlobCheckBlobExistsHeaders: ContainerRegistryBlobCheckBlobExistsHeaders,
    ContainerRegistryBlobDeleteBlobHeaders: ContainerRegistryBlobDeleteBlobHeaders,
    ContainerRegistryBlobMountBlobHeaders: ContainerRegistryBlobMountBlobHeaders,
    ContainerRegistryBlobGetUploadStatusHeaders: ContainerRegistryBlobGetUploadStatusHeaders,
    ContainerRegistryBlobUploadChunkHeaders: ContainerRegistryBlobUploadChunkHeaders,
    ContainerRegistryBlobCompleteUploadHeaders: ContainerRegistryBlobCompleteUploadHeaders,
    ContainerRegistryBlobStartUploadHeaders: ContainerRegistryBlobStartUploadHeaders,
    ContainerRegistryBlobGetChunkHeaders: ContainerRegistryBlobGetChunkHeaders,
    ContainerRegistryBlobCheckChunkExistsHeaders: ContainerRegistryBlobCheckChunkExistsHeaders
});

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const accept = {
    parameterPath: "accept",
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Accept",
        type: {
            name: "String"
        }
    }
};
const url = {
    parameterPath: "url",
    mapper: {
        serializedName: "url",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const name = {
    parameterPath: "name",
    mapper: {
        serializedName: "name",
        required: true,
        type: {
            name: "String"
        }
    }
};
const reference = {
    parameterPath: "reference",
    mapper: {
        serializedName: "reference",
        required: true,
        type: {
            name: "String"
        }
    }
};
const accept1 = {
    parameterPath: ["options", "accept"],
    mapper: {
        serializedName: "accept",
        type: {
            name: "String"
        }
    }
};
const contentType = {
    parameterPath: ["options", "contentType"],
    mapper: {
        defaultValue: "application/vnd.docker.distribution.manifest.v2+json",
        isConstant: true,
        serializedName: "Content-Type",
        type: {
            name: "String"
        }
    }
};
const payload = {
    parameterPath: "payload",
    mapper: Manifest
};
const last = {
    parameterPath: ["options", "last"],
    mapper: {
        serializedName: "last",
        type: {
            name: "String"
        }
    }
};
const n = {
    parameterPath: ["options", "n"],
    mapper: {
        serializedName: "n",
        type: {
            name: "Number"
        }
    }
};
const apiVersion = {
    parameterPath: "apiVersion",
    mapper: {
        serializedName: "api-version",
        required: true,
        type: {
            name: "String"
        }
    }
};
const contentType1 = {
    parameterPath: ["options", "contentType"],
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Content-Type",
        type: {
            name: "String"
        }
    }
};
const value = {
    parameterPath: ["options", "value"],
    mapper: RepositoryWriteableProperties
};
const orderby = {
    parameterPath: ["options", "orderby"],
    mapper: {
        serializedName: "orderby",
        type: {
            name: "String"
        }
    }
};
const digest = {
    parameterPath: ["options", "digest"],
    mapper: {
        serializedName: "digest",
        type: {
            name: "String"
        }
    }
};
const value1 = {
    parameterPath: ["options", "value"],
    mapper: TagWriteableProperties
};
const digest1 = {
    parameterPath: "digest",
    mapper: {
        serializedName: "digest",
        required: true,
        type: {
            name: "String"
        }
    }
};
const value2 = {
    parameterPath: ["options", "value"],
    mapper: ManifestWriteableProperties
};
const nextLink = {
    parameterPath: "nextLink",
    mapper: {
        serializedName: "nextLink",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const accept2 = {
    parameterPath: "accept",
    mapper: {
        defaultValue: "application/octet-stream",
        isConstant: true,
        serializedName: "Accept",
        type: {
            name: "String"
        }
    }
};
const fromParam = {
    parameterPath: "fromParam",
    mapper: {
        serializedName: "from",
        required: true,
        type: {
            name: "String"
        }
    }
};
const mount = {
    parameterPath: "mount",
    mapper: {
        serializedName: "mount",
        required: true,
        type: {
            name: "String"
        }
    }
};
const location = {
    parameterPath: "location",
    mapper: {
        serializedName: "nextBlobUuidLink",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const contentType2 = {
    parameterPath: ["options", "contentType"],
    mapper: {
        defaultValue: "application/octet-stream",
        isConstant: true,
        serializedName: "Content-Type",
        type: {
            name: "String"
        }
    }
};
const value3 = {
    parameterPath: "value",
    mapper: {
        serializedName: "value",
        required: true,
        type: {
            name: "Stream"
        }
    }
};
const accept3 = {
    parameterPath: "accept",
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Accept",
        type: {
            name: "String"
        }
    }
};
const value4 = {
    parameterPath: ["options", "value"],
    mapper: {
        serializedName: "value",
        type: {
            name: "Stream"
        }
    }
};
const digest2 = {
    parameterPath: "digest",
    mapper: {
        serializedName: "digest",
        required: true,
        type: {
            name: "String"
        }
    }
};
const range = {
    parameterPath: "range",
    mapper: {
        serializedName: "Range",
        required: true,
        type: {
            name: "String"
        }
    }
};
const contentType3 = {
    parameterPath: ["options", "contentType"],
    mapper: {
        defaultValue: "application/x-www-form-urlencoded",
        isConstant: true,
        serializedName: "Content-Type",
        type: {
            name: "String"
        }
    }
};
const grantType = {
    parameterPath: "grantType",
    mapper: {
        serializedName: "grant_type",
        required: true,
        type: {
            name: "String"
        }
    }
};
const service = {
    parameterPath: "service",
    mapper: {
        serializedName: "service",
        required: true,
        type: {
            name: "String"
        }
    }
};
const tenant = {
    parameterPath: ["options", "tenant"],
    mapper: {
        serializedName: "tenant",
        type: {
            name: "String"
        }
    }
};
const refreshToken = {
    parameterPath: ["options", "refreshToken"],
    mapper: {
        serializedName: "refresh_token",
        type: {
            name: "String"
        }
    }
};
const accessToken = {
    parameterPath: ["options", "accessToken"],
    mapper: {
        serializedName: "access_token",
        type: {
            name: "String"
        }
    }
};
const accept4 = {
    parameterPath: "accept",
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Accept",
        type: {
            name: "String"
        }
    }
};
const scope = {
    parameterPath: "scope",
    mapper: {
        serializedName: "scope",
        required: true,
        type: {
            name: "String"
        }
    }
};
const refreshToken1 = {
    parameterPath: "refreshToken",
    mapper: {
        serializedName: "refresh_token",
        required: true,
        type: {
            name: "String"
        }
    }
};
const grantType1 = {
    parameterPath: "grantType",
    mapper: {
        serializedName: "grant_type",
        required: true,
        type: {
            name: "Enum",
            allowedValues: ["refresh_token", "password"]
        }
    }
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing ContainerRegistry operations. */
class ContainerRegistryImpl {
    /**
     * Initialize a new instance of the class ContainerRegistry class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Tells whether this Docker Registry instance supports Docker Registry HTTP API v2
     * @param options The options parameters.
     */
    checkDockerV2Support(options) {
        return this.client.sendOperationRequest({ options }, checkDockerV2SupportOperationSpec);
    }
    /**
     * Get the manifest identified by `name` and `reference` where `reference` can be a tag or digest.
     * @param name Name of the image (including the namespace)
     * @param reference A tag or a digest, pointing to a specific image
     * @param options The options parameters.
     */
    getManifest(name, reference, options) {
        return this.client.sendOperationRequest({ name, reference, options }, getManifestOperationSpec);
    }
    /**
     * Put the manifest identified by `name` and `reference` where `reference` can be a tag or digest.
     * @param name Name of the image (including the namespace)
     * @param reference A tag or a digest, pointing to a specific image
     * @param payload Manifest body, can take v1 or v2 values depending on accept header
     * @param options The options parameters.
     */
    createManifest(name, reference, payload, options) {
        return this.client.sendOperationRequest({ name, reference, payload, options }, createManifestOperationSpec);
    }
    /**
     * Delete the manifest identified by `name` and `reference`. Note that a manifest can _only_ be deleted
     * by `digest`.
     * @param name Name of the image (including the namespace)
     * @param reference Digest of a BLOB
     * @param options The options parameters.
     */
    deleteManifest(name, reference, options) {
        return this.client.sendOperationRequest({ name, reference, options }, deleteManifestOperationSpec);
    }
    /**
     * List repositories
     * @param options The options parameters.
     */
    getRepositories(options) {
        return this.client.sendOperationRequest({ options }, getRepositoriesOperationSpec);
    }
    /**
     * Get repository attributes
     * @param name Name of the image (including the namespace)
     * @param options The options parameters.
     */
    getProperties(name, options) {
        return this.client.sendOperationRequest({ name, options }, getPropertiesOperationSpec);
    }
    /**
     * Delete the repository identified by `name`
     * @param name Name of the image (including the namespace)
     * @param options The options parameters.
     */
    deleteRepository(name, options) {
        return this.client.sendOperationRequest({ name, options }, deleteRepositoryOperationSpec);
    }
    /**
     * Update the attribute identified by `name` where `reference` is the name of the repository.
     * @param name Name of the image (including the namespace)
     * @param options The options parameters.
     */
    updateProperties(name, options) {
        return this.client.sendOperationRequest({ name, options }, updatePropertiesOperationSpec);
    }
    /**
     * List tags of a repository
     * @param name Name of the image (including the namespace)
     * @param options The options parameters.
     */
    getTags(name, options) {
        return this.client.sendOperationRequest({ name, options }, getTagsOperationSpec);
    }
    /**
     * Get tag attributes by tag
     * @param name Name of the image (including the namespace)
     * @param reference Tag name
     * @param options The options parameters.
     */
    getTagProperties(name, reference, options) {
        return this.client.sendOperationRequest({ name, reference, options }, getTagPropertiesOperationSpec);
    }
    /**
     * Update tag attributes
     * @param name Name of the image (including the namespace)
     * @param reference Tag name
     * @param options The options parameters.
     */
    updateTagAttributes(name, reference, options) {
        return this.client.sendOperationRequest({ name, reference, options }, updateTagAttributesOperationSpec);
    }
    /**
     * Delete tag
     * @param name Name of the image (including the namespace)
     * @param reference Tag name
     * @param options The options parameters.
     */
    deleteTag(name, reference, options) {
        return this.client.sendOperationRequest({ name, reference, options }, deleteTagOperationSpec);
    }
    /**
     * List manifests of a repository
     * @param name Name of the image (including the namespace)
     * @param options The options parameters.
     */
    getManifests(name, options) {
        return this.client.sendOperationRequest({ name, options }, getManifestsOperationSpec);
    }
    /**
     * Get manifest attributes
     * @param name Name of the image (including the namespace)
     * @param digest Digest of a BLOB
     * @param options The options parameters.
     */
    getManifestProperties(name, digest, options) {
        return this.client.sendOperationRequest({ name, digest, options }, getManifestPropertiesOperationSpec);
    }
    /**
     * Update properties of a manifest
     * @param name Name of the image (including the namespace)
     * @param digest Digest of a BLOB
     * @param options The options parameters.
     */
    updateManifestProperties(name, digest, options) {
        return this.client.sendOperationRequest({ name, digest, options }, updateManifestPropertiesOperationSpec);
    }
    /**
     * GetRepositoriesNext
     * @param nextLink The nextLink from the previous successful call to the GetRepositories method.
     * @param options The options parameters.
     */
    getRepositoriesNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, getRepositoriesNextOperationSpec);
    }
    /**
     * GetTagsNext
     * @param name Name of the image (including the namespace)
     * @param nextLink The nextLink from the previous successful call to the GetTags method.
     * @param options The options parameters.
     */
    getTagsNext(name, nextLink, options) {
        return this.client.sendOperationRequest({ name, nextLink, options }, getTagsNextOperationSpec);
    }
    /**
     * GetManifestsNext
     * @param name Name of the image (including the namespace)
     * @param nextLink The nextLink from the previous successful call to the GetManifests method.
     * @param options The options parameters.
     */
    getManifestsNext(name, nextLink, options) {
        return this.client.sendOperationRequest({ name, nextLink, options }, getManifestsNextOperationSpec);
    }
}
// Operation Specifications
const serializer = coreClient.createSerializer(Mappers, /* isXml */ false);
const checkDockerV2SupportOperationSpec = {
    path: "/v2/",
    httpMethod: "GET",
    responses: {
        200: {},
        default: {
            bodyMapper: AcrErrors
        }
    },
    urlParameters: [url],
    headerParameters: [accept],
    serializer
};
const getManifestOperationSpec = {
    path: "/v2/{name}/manifests/{reference}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ManifestWrapper
        },
        default: {
            bodyMapper: AcrErrors
        }
    },
    urlParameters: [url, name, reference],
    headerParameters: [accept, accept1],
    serializer
};
const createManifestOperationSpec = {
    path: "/v2/{name}/manifests/{reference}",
    httpMethod: "PUT",
    responses: {
        201: {
            bodyMapper: { type: { name: "any" } },
            headersMapper: ContainerRegistryCreateManifestHeaders
        },
        default: {
            bodyMapper: AcrErrors
        }
    },
    requestBody: payload,
    urlParameters: [url, name, reference],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer
};
const deleteManifestOperationSpec = {
    path: "/v2/{name}/manifests/{reference}",
    httpMethod: "DELETE",
    responses: {
        202: {},
        404: {},
        default: {
            bodyMapper: AcrErrors
        }
    },
    urlParameters: [url, name, reference],
    headerParameters: [accept],
    serializer
};
const getRepositoriesOperationSpec = {
    path: "/acr/v1/_catalog",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Repositories,
            headersMapper: ContainerRegistryGetRepositoriesHeaders
        },
        default: {
            bodyMapper: AcrErrors
        }
    },
    queryParameters: [last, n, apiVersion],
    urlParameters: [url],
    headerParameters: [accept],
    serializer
};
const getPropertiesOperationSpec = {
    path: "/acr/v1/{name}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ContainerRepositoryProperties
        },
        default: {
            bodyMapper: AcrErrors
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [url, name],
    headerParameters: [accept],
    serializer
};
const deleteRepositoryOperationSpec = {
    path: "/acr/v1/{name}",
    httpMethod: "DELETE",
    responses: {
        202: {},
        404: {},
        default: {
            bodyMapper: AcrErrors
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [url, name],
    headerParameters: [accept],
    serializer
};
const updatePropertiesOperationSpec = {
    path: "/acr/v1/{name}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: ContainerRepositoryProperties
        },
        default: {
            bodyMapper: AcrErrors
        }
    },
    requestBody: value,
    queryParameters: [apiVersion],
    urlParameters: [url, name],
    headerParameters: [accept, contentType1],
    mediaType: "json",
    serializer
};
const getTagsOperationSpec = {
    path: "/acr/v1/{name}/_tags",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: TagList,
            headersMapper: ContainerRegistryGetTagsHeaders
        },
        default: {
            bodyMapper: AcrErrors
        }
    },
    queryParameters: [
        last,
        n,
        apiVersion,
        orderby,
        digest
    ],
    urlParameters: [url, name],
    headerParameters: [accept],
    serializer
};
const getTagPropertiesOperationSpec = {
    path: "/acr/v1/{name}/_tags/{reference}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ArtifactTagProperties
        },
        default: {
            bodyMapper: AcrErrors
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [url, name, reference],
    headerParameters: [accept],
    serializer
};
const updateTagAttributesOperationSpec = {
    path: "/acr/v1/{name}/_tags/{reference}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: ArtifactTagProperties
        },
        default: {
            bodyMapper: AcrErrors
        }
    },
    requestBody: value1,
    queryParameters: [apiVersion],
    urlParameters: [url, name, reference],
    headerParameters: [accept, contentType1],
    mediaType: "json",
    serializer
};
const deleteTagOperationSpec = {
    path: "/acr/v1/{name}/_tags/{reference}",
    httpMethod: "DELETE",
    responses: {
        202: {},
        404: {},
        default: {
            bodyMapper: AcrErrors
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [url, name, reference],
    headerParameters: [accept],
    serializer
};
const getManifestsOperationSpec = {
    path: "/acr/v1/{name}/_manifests",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AcrManifests,
            headersMapper: ContainerRegistryGetManifestsHeaders
        },
        default: {
            bodyMapper: AcrErrors
        }
    },
    queryParameters: [
        last,
        n,
        apiVersion,
        orderby
    ],
    urlParameters: [url, name],
    headerParameters: [accept],
    serializer
};
const getManifestPropertiesOperationSpec = {
    path: "/acr/v1/{name}/_manifests/{digest}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ArtifactManifestProperties
        },
        default: {
            bodyMapper: AcrErrors
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [url, name, digest1],
    headerParameters: [accept],
    serializer
};
const updateManifestPropertiesOperationSpec = {
    path: "/acr/v1/{name}/_manifests/{digest}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: ArtifactManifestProperties
        },
        default: {
            bodyMapper: AcrErrors
        }
    },
    requestBody: value2,
    queryParameters: [apiVersion],
    urlParameters: [url, name, digest1],
    headerParameters: [accept, contentType1],
    mediaType: "json",
    serializer
};
const getRepositoriesNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Repositories,
            headersMapper: ContainerRegistryGetRepositoriesNextHeaders
        },
        default: {
            bodyMapper: AcrErrors
        }
    },
    queryParameters: [last, n, apiVersion],
    urlParameters: [url, nextLink],
    headerParameters: [accept],
    serializer
};
const getTagsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: TagList,
            headersMapper: ContainerRegistryGetTagsNextHeaders
        },
        default: {
            bodyMapper: AcrErrors
        }
    },
    queryParameters: [
        last,
        n,
        apiVersion,
        orderby,
        digest
    ],
    urlParameters: [url, name, nextLink],
    headerParameters: [accept],
    serializer
};
const getManifestsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AcrManifests,
            headersMapper: ContainerRegistryGetManifestsNextHeaders
        },
        default: {
            bodyMapper: AcrErrors
        }
    },
    queryParameters: [
        last,
        n,
        apiVersion,
        orderby
    ],
    urlParameters: [url, name, nextLink],
    headerParameters: [accept],
    serializer
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing ContainerRegistryBlob operations. */
class ContainerRegistryBlobImpl {
    /**
     * Initialize a new instance of the class ContainerRegistryBlob class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Retrieve the blob from the registry identified by digest.
     * @param name Name of the image (including the namespace)
     * @param digest Digest of a BLOB
     * @param options The options parameters.
     */
    getBlob(name, digest, options) {
        return this.client.sendOperationRequest({ name, digest, options }, getBlobOperationSpec);
    }
    /**
     * Same as GET, except only the headers are returned.
     * @param name Name of the image (including the namespace)
     * @param digest Digest of a BLOB
     * @param options The options parameters.
     */
    checkBlobExists(name, digest, options) {
        return this.client.sendOperationRequest({ name, digest, options }, checkBlobExistsOperationSpec);
    }
    /**
     * Removes an already uploaded blob.
     * @param name Name of the image (including the namespace)
     * @param digest Digest of a BLOB
     * @param options The options parameters.
     */
    deleteBlob(name, digest, options) {
        return this.client.sendOperationRequest({ name, digest, options }, deleteBlobOperationSpec);
    }
    /**
     * Mount a blob identified by the `mount` parameter from another repository.
     * @param name Name of the image (including the namespace)
     * @param mount Digest of blob to mount from the source repository.
     * @param fromParam Name of the source repository.
     * @param options The options parameters.
     */
    mountBlob(name, mount, fromParam, options) {
        return this.client.sendOperationRequest({ name, mount, fromParam, options }, mountBlobOperationSpec);
    }
    /**
     * Retrieve status of upload identified by uuid. The primary purpose of this endpoint is to resolve the
     * current status of a resumable upload.
     * @param location Link acquired from upload start or previous chunk. Note, do not include initial /
     *                 (must do substring(1) )
     * @param options The options parameters.
     */
    getUploadStatus(location, options) {
        return this.client.sendOperationRequest({ location, options }, getUploadStatusOperationSpec);
    }
    /**
     * Upload a stream of data without completing the upload.
     * @param location Link acquired from upload start or previous chunk. Note, do not include initial /
     *                 (must do substring(1) )
     * @param value Raw data of blob
     * @param options The options parameters.
     */
    uploadChunk(location, value, options) {
        return this.client.sendOperationRequest({ location, value, options }, uploadChunkOperationSpec);
    }
    /**
     * Complete the upload, providing all the data in the body, if necessary. A request without a body will
     * just complete the upload with previously uploaded content.
     * @param digest Digest of a BLOB
     * @param location Link acquired from upload start or previous chunk. Note, do not include initial /
     *                 (must do substring(1) )
     * @param options The options parameters.
     */
    completeUpload(digest, location, options) {
        return this.client.sendOperationRequest({ digest, location, options }, completeUploadOperationSpec);
    }
    /**
     * Cancel outstanding upload processes, releasing associated resources. If this is not called, the
     * unfinished uploads will eventually timeout.
     * @param location Link acquired from upload start or previous chunk. Note, do not include initial /
     *                 (must do substring(1) )
     * @param options The options parameters.
     */
    cancelUpload(location, options) {
        return this.client.sendOperationRequest({ location, options }, cancelUploadOperationSpec);
    }
    /**
     * Initiate a resumable blob upload with an empty request body.
     * @param name Name of the image (including the namespace)
     * @param options The options parameters.
     */
    startUpload(name, options) {
        return this.client.sendOperationRequest({ name, options }, startUploadOperationSpec);
    }
    /**
     * Retrieve the blob from the registry identified by `digest`. This endpoint may also support RFC7233
     * compliant range requests. Support can be detected by issuing a HEAD request. If the header
     * `Accept-Range: bytes` is returned, range requests can be used to fetch partial content.
     * @param name Name of the image (including the namespace)
     * @param digest Digest of a BLOB
     * @param range Format : bytes=<start>-<end>,  HTTP Range header specifying blob chunk.
     * @param options The options parameters.
     */
    getChunk(name, digest, range, options) {
        return this.client.sendOperationRequest({ name, digest, range, options }, getChunkOperationSpec);
    }
    /**
     * Same as GET, except only the headers are returned.
     * @param name Name of the image (including the namespace)
     * @param digest Digest of a BLOB
     * @param range Format : bytes=<start>-<end>,  HTTP Range header specifying blob chunk.
     * @param options The options parameters.
     */
    checkChunkExists(name, digest, range, options) {
        return this.client.sendOperationRequest({ name, digest, range, options }, checkChunkExistsOperationSpec);
    }
}
// Operation Specifications
const serializer$1 = coreClient.createSerializer(Mappers, /* isXml */ false);
const getBlobOperationSpec = {
    path: "/v2/{name}/blobs/{digest}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: {
                type: { name: "Stream" },
                serializedName: "parsedResponse"
            },
            headersMapper: ContainerRegistryBlobGetBlobHeaders
        },
        307: {
            headersMapper: ContainerRegistryBlobGetBlobHeaders
        },
        default: {}
    },
    urlParameters: [url, name, digest1],
    headerParameters: [accept2],
    serializer: serializer$1
};
const checkBlobExistsOperationSpec = {
    path: "/v2/{name}/blobs/{digest}",
    httpMethod: "HEAD",
    responses: {
        200: {
            headersMapper: ContainerRegistryBlobCheckBlobExistsHeaders
        },
        307: {
            headersMapper: ContainerRegistryBlobCheckBlobExistsHeaders
        },
        default: {
            bodyMapper: AcrErrors
        }
    },
    urlParameters: [url, name, digest1],
    headerParameters: [accept],
    serializer: serializer$1
};
const deleteBlobOperationSpec = {
    path: "/v2/{name}/blobs/{digest}",
    httpMethod: "DELETE",
    responses: {
        202: {
            bodyMapper: {
                type: { name: "Stream" },
                serializedName: "parsedResponse"
            },
            headersMapper: ContainerRegistryBlobDeleteBlobHeaders
        },
        default: {}
    },
    urlParameters: [url, name, digest1],
    headerParameters: [accept2],
    serializer: serializer$1
};
const mountBlobOperationSpec = {
    path: "/v2/{name}/blobs/uploads/",
    httpMethod: "POST",
    responses: {
        201: {
            headersMapper: ContainerRegistryBlobMountBlobHeaders
        },
        default: {
            bodyMapper: AcrErrors
        }
    },
    queryParameters: [fromParam, mount],
    urlParameters: [url, name],
    headerParameters: [accept],
    serializer: serializer$1
};
const getUploadStatusOperationSpec = {
    path: "/{nextBlobUuidLink}",
    httpMethod: "GET",
    responses: {
        204: {
            headersMapper: ContainerRegistryBlobGetUploadStatusHeaders
        },
        default: {
            bodyMapper: AcrErrors
        }
    },
    urlParameters: [url, location],
    headerParameters: [accept],
    serializer: serializer$1
};
const uploadChunkOperationSpec = {
    path: "/{nextBlobUuidLink}",
    httpMethod: "PATCH",
    responses: {
        202: {
            headersMapper: ContainerRegistryBlobUploadChunkHeaders
        },
        default: {
            bodyMapper: AcrErrors
        }
    },
    requestBody: value3,
    urlParameters: [url, location],
    headerParameters: [contentType2, accept3],
    mediaType: "binary",
    serializer: serializer$1
};
const completeUploadOperationSpec = {
    path: "/{nextBlobUuidLink}",
    httpMethod: "PUT",
    responses: {
        201: {
            headersMapper: ContainerRegistryBlobCompleteUploadHeaders
        },
        default: {
            bodyMapper: AcrErrors
        }
    },
    requestBody: value4,
    queryParameters: [digest2],
    urlParameters: [url, location],
    headerParameters: [contentType2, accept3],
    mediaType: "binary",
    serializer: serializer$1
};
const cancelUploadOperationSpec = {
    path: "/{nextBlobUuidLink}",
    httpMethod: "DELETE",
    responses: {
        204: {},
        default: {
            bodyMapper: AcrErrors
        }
    },
    urlParameters: [url, location],
    headerParameters: [accept],
    serializer: serializer$1
};
const startUploadOperationSpec = {
    path: "/v2/{name}/blobs/uploads/",
    httpMethod: "POST",
    responses: {
        202: {
            headersMapper: ContainerRegistryBlobStartUploadHeaders
        },
        default: {
            bodyMapper: AcrErrors
        }
    },
    urlParameters: [url, name],
    headerParameters: [accept],
    serializer: serializer$1
};
const getChunkOperationSpec = {
    path: "/v2/{name}/blobs/{digest}",
    httpMethod: "GET",
    responses: {
        206: {
            bodyMapper: {
                type: { name: "Stream" },
                serializedName: "parsedResponse"
            },
            headersMapper: ContainerRegistryBlobGetChunkHeaders
        },
        default: {}
    },
    urlParameters: [url, name, digest1],
    headerParameters: [accept2, range],
    serializer: serializer$1
};
const checkChunkExistsOperationSpec = {
    path: "/v2/{name}/blobs/{digest}",
    httpMethod: "HEAD",
    responses: {
        200: {
            headersMapper: ContainerRegistryBlobCheckChunkExistsHeaders
        },
        default: {
            bodyMapper: AcrErrors
        }
    },
    urlParameters: [url, name, digest1],
    headerParameters: [accept, range],
    serializer: serializer$1
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing Authentication operations. */
class AuthenticationImpl {
    /**
     * Initialize a new instance of the class Authentication class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Exchange AAD tokens for an ACR refresh Token
     * @param grantType Can take a value of access_token_refresh_token, or access_token, or refresh_token
     * @param service Indicates the name of your Azure container registry.
     * @param options The options parameters.
     */
    exchangeAadAccessTokenForAcrRefreshToken(grantType, service, options) {
        return this.client.sendOperationRequest({ grantType, service, options }, exchangeAadAccessTokenForAcrRefreshTokenOperationSpec);
    }
    /**
     * Exchange ACR Refresh token for an ACR Access Token
     * @param service Indicates the name of your Azure container registry.
     * @param scope Which is expected to be a valid scope, and can be specified more than once for multiple
     *              scope requests. You obtained this from the Www-Authenticate response header from the challenge.
     * @param refreshToken Must be a valid ACR refresh token
     * @param grantType Grant type is expected to be refresh_token
     * @param options The options parameters.
     */
    exchangeAcrRefreshTokenForAcrAccessToken(service, scope, refreshToken, grantType, options) {
        return this.client.sendOperationRequest({ service, scope, refreshToken, grantType, options }, exchangeAcrRefreshTokenForAcrAccessTokenOperationSpec);
    }
}
// Operation Specifications
const serializer$2 = coreClient.createSerializer(Mappers, /* isXml */ false);
const exchangeAadAccessTokenForAcrRefreshTokenOperationSpec = {
    path: "/oauth2/exchange",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: AcrRefreshToken
        },
        default: {
            bodyMapper: AcrErrors
        }
    },
    formDataParameters: [
        grantType,
        service,
        tenant,
        refreshToken,
        accessToken
    ],
    queryParameters: [apiVersion],
    urlParameters: [url],
    headerParameters: [contentType3, accept4],
    serializer: serializer$2
};
const exchangeAcrRefreshTokenForAcrAccessTokenOperationSpec = {
    path: "/oauth2/token",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: AcrAccessToken
        },
        default: {
            bodyMapper: AcrErrors
        }
    },
    formDataParameters: [
        service,
        scope,
        refreshToken1,
        grantType1
    ],
    queryParameters: [apiVersion],
    urlParameters: [url],
    headerParameters: [contentType3, accept4],
    serializer: serializer$2
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** @internal */
class GeneratedClientContext extends coreClient.ServiceClient {
    /**
     * Initializes a new instance of the GeneratedClientContext class.
     * @param url Registry login URL
     * @param apiVersion Api Version
     * @param options The parameter options
     */
    constructor(url, apiVersion, options) {
        if (url === undefined) {
            throw new Error("'url' cannot be null");
        }
        if (apiVersion === undefined) {
            throw new Error("'apiVersion' cannot be null");
        }
        // Initializing default values for options
        if (!options) {
            options = {};
        }
        const defaults = {
            requestContentType: "application/json; charset=utf-8"
        };
        const packageDetails = `azsdk-js-container-registry/1.0.0`;
        const userAgentPrefix = options.userAgentOptions && options.userAgentOptions.userAgentPrefix
            ? `${options.userAgentOptions.userAgentPrefix} ${packageDetails}`
            : `${packageDetails}`;
        const optionsWithDefaults = Object.assign(Object.assign(Object.assign({}, defaults), options), { userAgentOptions: {
                userAgentPrefix
            }, baseUri: options.endpoint || "{url}" });
        super(optionsWithDefaults);
        // Parameter assignments
        this.url = url;
        this.apiVersion = apiVersion;
    }
}

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** @internal */
class GeneratedClient extends GeneratedClientContext {
    /**
     * Initializes a new instance of the GeneratedClient class.
     * @param url Registry login URL
     * @param apiVersion Api Version
     * @param options The parameter options
     */
    constructor(url, apiVersion, options) {
        super(url, apiVersion, options);
        this.containerRegistry = new ContainerRegistryImpl(this);
        this.containerRegistryBlob = new ContainerRegistryBlobImpl(this);
        this.authentication = new AuthenticationImpl(this);
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * Creates a span using the global tracer.
 *
 * @param name - The name of the operation being performed.
 * @param tracingOptions - The options for the underlying http request.
 *
 * @internal
 */
const createSpan = coreTracing.createSpanFunction({
    namespace: "Azure.Containers",
    packagePrefix: "Azure.Containers.ContainerRegistry",
});

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Extract the path part from the next link value returned by the service,
 * @internal
 */
function extractNextLink(value) {
    // The link value has this pattern
    //     `</acr/v1/name/...&n=2&orderby=>; rel="next"`
    // and we only want the part inside of <...>
    return value === null || value === void 0 ? void 0 : value.substr(1, value.indexOf(">") - 1);
}
/**
 * Checks whether a string is a digest
 * @internal
 */
function isDigest(tagOrDigest) {
    return tagOrDigest.includes(":");
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Parses an WWW-Authenticate response.
 * This transforms a string value like:
 * `Bearer authorization="some_authorization", resource="https://some.url"`
 * into an object like:
 * `{ authorization: "some_authorization", resource: "https://some.url" }`
 * @param wwwAuthenticate - String value in the WWW-Authenticate header
 */
function parseWWWAuthenticate(wwwAuthenticate) {
    // First we split the string by either `,`, `, ` or ` `.
    const parts = wwwAuthenticate.split(/, *| +/);
    // Then we only keep the strings with an equal sign after a word and before a quote.
    // also splitting these sections by their equal sign
    const keyValues = parts.reduce((acc, str) => (str.match(/\w="/) ? [...acc, str.split("=")] : acc), []);
    // Then we transform these key-value pairs back into an object.
    const parsed = keyValues.reduce((result, [key, value]) => (Object.assign(Object.assign({}, result), { [key]: value.slice(1, -1) })), {});
    return parsed;
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
function delay(t, value) {
    return new Promise((resolve) => setTimeout(() => resolve(value), t));
}
// Default options for the cycler if none are provided
const DEFAULT_CYCLER_OPTIONS = {
    forcedRefreshWindowInMs: 1000,
    retryIntervalInMs: 3000,
    refreshWindowInMs: 1000 * 60 * 2, // Start refreshing 2m before expiry
};
/**
 * Converts an an unreliable access token getter (which may resolve with null)
 * into an AccessTokenGetter by retrying the unreliable getter in a regular
 * interval.
 *
 * @param getAccessToken - A function that produces a promise of an access token that may fail by returning null.
 * @param retryIntervalInMs - The time (in milliseconds) to wait between retry attempts.
 * @param refreshTimeout - The timestamp after which the refresh attempt will fail, throwing an exception.
 * @returns - A promise that, if it resolves, will resolve with an access token.
 */
async function beginRefresh(getAccessToken, retryIntervalInMs, refreshTimeout) {
    // This wrapper handles exceptions gracefully as long as we haven't exceeded
    // the timeout.
    async function tryGetAccessToken() {
        if (Date.now() < refreshTimeout) {
            try {
                return await getAccessToken();
            }
            catch (_a) {
                return null;
            }
        }
        else {
            const finalToken = await getAccessToken();
            // Timeout is up, so throw if it's still null
            if (finalToken === null) {
                throw new Error("Failed to refresh access token.");
            }
            return finalToken;
        }
    }
    let token = await tryGetAccessToken();
    while (token === null) {
        await delay(retryIntervalInMs);
        token = await tryGetAccessToken();
    }
    return token;
}
/**
 * Creates a token cycler from a credential, scopes, and optional settings.
 *
 * A token cycler represents a way to reliably retrieve a valid access token
 * from a TokenCredential. It will handle initializing the token, refreshing it
 * when it nears expiration, and synchronizes refresh attempts to avoid
 * concurrency hazards.
 *
 * @param credential - the underlying TokenCredential that provides the access
 * token
 * @param tokenCyclerOptions - optionally override default settings for the cycler
 *
 * @returns - a function that reliably produces a valid access token
 */
function createTokenCycler(credential, tokenCyclerOptions) {
    let refreshWorker = null;
    let token = null;
    const options = Object.assign(Object.assign({}, DEFAULT_CYCLER_OPTIONS), tokenCyclerOptions);
    /**
     * This little holder defines several predicates that we use to construct
     * the rules of refreshing the token.
     */
    const cycler = {
        /**
         * Produces true if a refresh job is currently in progress.
         */
        get isRefreshing() {
            return refreshWorker !== null;
        },
        /**
         * Produces true if the cycler SHOULD refresh (we are within the refresh
         * window and not already refreshing)
         */
        get shouldRefresh() {
            var _a;
            return (!cycler.isRefreshing &&
                ((_a = token === null || token === void 0 ? void 0 : token.expiresOnTimestamp) !== null && _a !== void 0 ? _a : 0) - options.refreshWindowInMs < Date.now());
        },
        /**
         * Produces true if the cycler MUST refresh (null or nearly-expired
         * token).
         */
        get mustRefresh() {
            return (token === null || token.expiresOnTimestamp - options.forcedRefreshWindowInMs < Date.now());
        },
    };
    /**
     * Starts a refresh job or returns the existing job if one is already
     * running.
     */
    function refresh(scopes, getTokenOptions) {
        var _a;
        if (!cycler.isRefreshing) {
            // We bind `scopes` here to avoid passing it around a lot
            const tryGetAccessToken = () => credential.getToken(scopes, getTokenOptions);
            // Take advantage of promise chaining to insert an assignment to `token`
            // before the refresh can be considered done.
            refreshWorker = beginRefresh(tryGetAccessToken, options.retryIntervalInMs, 
            // If we don't have a token, then we should timeout immediately
            (_a = token === null || token === void 0 ? void 0 : token.expiresOnTimestamp) !== null && _a !== void 0 ? _a : Date.now())
                .then((_token) => {
                refreshWorker = null;
                token = _token;
                return token;
            })
                .catch((reason) => {
                // We also should reset the refresher if we enter a failed state.  All
                // existing awaiters will throw, but subsequent requests will start a
                // new retry chain.
                refreshWorker = null;
                token = null;
                throw reason;
            });
        }
        return refreshWorker;
    }
    return {
        get cachedToken() {
            return token || undefined;
        },
        getToken: async (scopes, tokenOptions) => {
            //
            // Simple rules:
            // - If we MUST refresh, then return the refresh task, blocking
            //   the pipeline until a token is available.
            // - If we SHOULD refresh, then run refresh but don't return it
            //   (we can still use the cached token).
            // - Return the token, since it's fine if we didn't return in
            //   step 1.
            //
            if (cycler.mustRefresh)
                return refresh(scopes, tokenOptions);
            if (cycler.shouldRefresh) {
                refresh(scopes, tokenOptions);
            }
            return token;
        },
    };
}

// Copyright (c) Microsoft Corporation.
const fiveMinutesInMs = 5 * 60 * 1000;
/**
 * Handles challenge based authentication for Container Registry Service.
 *```
 *  The challenge-based authorization flow for ACR is illustrated in the following steps.
 *  For example, GET /api/v1/acr/repositories translates into the following calls.
 *      Step 1: GET /api/v1/acr/repositories
 *  Return Header: 401: www-authenticate header - Bearer realm="{url}",service="{serviceName}",scope="{scope}",error="invalid_token"
 *      Step 2: Retrieve the serviceName, scope from the WWW-Authenticate header.  (Parse the string.)
 *      Step 3: POST /api/oauth2/exchange
 *  Request Body : { service, scope, grant-type, aadToken with ARM scope }
 *  Response Body: { acrRefreshToken }
 *      Step 4: POST /api/oauth2/token
 *  Request Body: { acrRefreshToken, scope, grant-type }
 *  Response Body: { acrAccessToken }
 *      Step 5: GET /api/v1/acr/repositories
 *  Request Header: { Bearer acrTokenAccess }
 *```
 */
class ChallengeHandler {
    constructor(credential, options = {}) {
        this.credential = credential;
        this.options = options;
        this.cycler = createTokenCycler(credential, {
            refreshWindowInMs: fiveMinutesInMs,
        });
    }
    authorizeRequest(_options) {
        return Promise.resolve();
    }
    /**
     * Updates  the authentication context based on the challenge.
     */
    async authorizeRequestOnChallenge(options) {
        var _a;
        // Once we're here, we've completed Step 1.
        const challenge = (_a = options.response) === null || _a === void 0 ? void 0 : _a.headers.get("WWW-Authenticate");
        if (!challenge) {
            throw new Error("Failed to retrieve challenge from response headers");
        }
        // Step 2: Parse challenge string to retrieve serviceName and scope, where scope is the ACR Scope
        const { service, scope } = parseWWWAuthenticate(challenge);
        if (!service) {
            throw new Error("Failed to retrieve 'service' from challenge");
        }
        if (!scope) {
            throw new Error("Failed to retrieve 'scope' from challenge");
        }
        // Step 3: Exchange AAD Access Token for ACR Refresh Token
        //   For anonymous access, we send the request with grant_type=password and an empty ACR refresh token
        //   For non-anonymous access, we get an AAD token then exchange it for an ACR fresh token
        let grantType;
        let acrRefreshToken;
        if (this.credential.isAnonymousAccess) {
            grantType = "password";
            acrRefreshToken = "";
        }
        else {
            grantType = "refresh_token";
            acrRefreshToken = (await this.cycler.getToken(scope, Object.assign(Object.assign({}, options), { service }))).token;
        }
        // Step 4: Send in acrRefreshToken and get back acrAccessToken
        const acrAccessToken = await this.credential.tokenService.ExchangeAcrRefreshTokenForAcrAccessTokenAsync(acrRefreshToken, service, scope, grantType, this.options);
        // Step 5 - Authorize Request.  At this point we're done with AAD and using an ACR access token.
        options.request.headers.set("Authorization", `Bearer ${acrAccessToken}`);
        return true;
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
function toManifestWritableProperties(from) {
    // don't return unwanted properties, namely `quarantineState` and `quarantineDetails`
    return from
        ? {
            canDelete: from.canDelete,
            canList: from.canList,
            canRead: from.canRead,
            canWrite: from.canWrite,
        }
        : undefined;
}
function toArtifactManifestProperties(from, repositoryName, registryLoginServer) {
    var _a, _b, _c, _d;
    return Object.assign({ registryLoginServer,
        repositoryName, digest: from.digest, sizeInBytes: from.size, createdOn: from.createdOn, lastUpdatedOn: from.lastUpdatedOn, architecture: (_a = from.architecture) !== null && _a !== void 0 ? _a : undefined, operatingSystem: (_b = from.operatingSystem) !== null && _b !== void 0 ? _b : undefined, relatedArtifacts: (_c = from.relatedArtifacts) !== null && _c !== void 0 ? _c : [], tags: (_d = from.tags) !== null && _d !== void 0 ? _d : [] }, toManifestWritableProperties(from));
}
function toServiceTagOrderBy(orderBy) {
    return orderBy === "LastUpdatedOnAscending"
        ? "timeasc"
        : orderBy === "LastUpdatedOnDescending"
            ? "timedesc"
            : undefined;
}
function toServiceManifestOrderBy(orderBy) {
    return orderBy === "LastUpdatedOnAscending"
        ? "timeasc"
        : orderBy === "LastUpdatedOnDescending"
            ? "timedesc"
            : undefined;
}

// Copyright (c) Microsoft Corporation.
/**
 * The client class used to interact with the Container Registry service.
 * @internal
 */
class RegistryArtifactImpl {
    /**
     * Creates an instance of a RegistryArtifact.
     * @param registryEndpoint - the URL to the Container Registry endpoint
     * @param repositoryName - the name of the repository
     * @param tagOrDigest - the tag or digest of this artifact
     * @param client - the generated client that interacts with service
     */
    constructor(registryEndpoint, repositoryName, tagOrDigest, client) {
        this.tagOrDigest = tagOrDigest;
        this.registryEndpoint = registryEndpoint;
        this.repositoryName = repositoryName;
        const parsedUrl = new url$1.URL(registryEndpoint);
        if (isDigest(tagOrDigest)) {
            this.digest = tagOrDigest;
            this.fullyQualifiedReference = `${parsedUrl.hostname}/${repositoryName}@${this.digest}`;
        }
        else {
            this.fullyQualifiedReference = `${parsedUrl.hostname}/${repositoryName}:${tagOrDigest}`;
        }
        this.client = client;
    }
    /**
     * digest of this artifact.
     */
    async getDigest() {
        if (this.digest) {
            return this.digest;
        }
        if (!isDigest(this.tagOrDigest)) {
            this.digest = (await this.getTagProperties(this.tagOrDigest)).digest;
        }
        else {
            this.digest = this.tagOrDigest;
        }
        return this.digest;
    }
    /**
     * Deletes this registry artifact by deleting its manifest.
     * @param options -
     */
    async delete(options = {}) {
        const { span, updatedOptions } = createSpan("RegistryArtifact-delete", options);
        try {
            await this.client.containerRegistry.deleteManifest(this.repositoryName, await this.getDigest(), updatedOptions);
        }
        catch (e) {
            span.setStatus({ code: coreTracing.SpanStatusCode.ERROR, message: e.message });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Deletes a tag. This removes the tag from the artifact and its manifest.
     * @param tag - the name of the tag to delete.
     * @param options -
     */
    async deleteTag(tag, options = {}) {
        if (!tag) {
            throw new Error("invalid tag");
        }
        const { span, updatedOptions } = createSpan("RegistryArtifact-deleteTag", options);
        try {
            await this.client.containerRegistry.deleteTag(this.repositoryName, tag, updatedOptions);
        }
        catch (e) {
            span.setStatus({ code: coreTracing.SpanStatusCode.ERROR, message: e.message });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Retrieves the properties of the manifest that uniquely identifies this artifact.
     * @param options -
     */
    async getManifestProperties(options = {}) {
        const { span, updatedOptions } = createSpan("RegistryArtifact-getManifestProperties", options);
        try {
            const result = await this.client.containerRegistry.getManifestProperties(this.repositoryName, await this.getDigest(), updatedOptions);
            return toArtifactManifestProperties(result, this.repositoryName, result.registryLoginServer);
        }
        catch (e) {
            span.setStatus({ code: coreTracing.SpanStatusCode.ERROR, message: e.message });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Updates the properties of the artifact's manifest.
     *
     * Example usage:
     *
     * ```javascript
     * const client = new ContainerRegistryClient(url, credential);
     * const artifact = client.getArtifact(repositoryName, artifactTagOrDigest)
     * const updated = await artifact.updateManifestProperties({
     *   canDelete: false,
     *   canList: false,
     *   canRead: false,
     *   canWrite: false
     * });
     * ```
     * @param options -
     */
    async updateManifestProperties(options) {
        const { span, updatedOptions } = createSpan("RegistryArtifact-updateManifestProperties", Object.assign(Object.assign({}, options), { value: {
                canDelete: options.canDelete,
                canWrite: options.canWrite,
                canList: options.canList,
                canRead: options.canRead,
            } }));
        try {
            const result = await this.client.containerRegistry.updateManifestProperties(this.repositoryName, await this.getDigest(), updatedOptions);
            return toArtifactManifestProperties(result, this.repositoryName, result.registryLoginServer);
        }
        catch (e) {
            span.setStatus({ code: coreTracing.SpanStatusCode.ERROR, message: e.message });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Retrieves the properties of the specified tag.
     * @param tag - the tag to retrieve properties.
     * @param options -
     */
    async getTagProperties(tag, options = {}) {
        if (!tag) {
            throw new Error("invalid tag");
        }
        const { span, updatedOptions } = createSpan("RegistryArtifact-getTagProperties", options);
        try {
            return await this.client.containerRegistry.getTagProperties(this.repositoryName, tag, updatedOptions);
        }
        catch (e) {
            span.setStatus({ code: coreTracing.SpanStatusCode.ERROR, message: e.message });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Updates the properties of a given tag.
     *
     * Example usage:
     *
     * ```javascript
     * const client = new ContainerRegistryClient(url, credential);
     * const artifact = client.getArtifact(repositoryName, artifactTagOrDigest)
     * const updated = await artifact.updateTagProperties(tag, {
     *   canDelete: false,
     *   canList: false,
     *   canRead: false,
     *   canWrite: false
     * });
     * ```
     * @param tag - name of the tag to update properties on
     * @param options -
     */
    async updateTagProperties(tag, options) {
        if (!tag) {
            throw new Error("invalid tag");
        }
        const { span, updatedOptions } = createSpan("RegistryArtifact-updateTagProperties", Object.assign(Object.assign({}, options), { value: {
                canDelete: options.canDelete,
                canWrite: options.canWrite,
                canList: options.canList,
                canRead: options.canRead,
            } }));
        try {
            return await this.client.containerRegistry.updateTagAttributes(this.repositoryName, tag, updatedOptions);
        }
        catch (e) {
            span.setStatus({ code: coreTracing.SpanStatusCode.ERROR, message: e.message });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Returns an async iterable iterator to list the tags that uniquely identify this artifact and the properties of each.
     *
     * Example using `for-await-of` syntax:
     *
     * ```javascript
     * const client = new ContainerRegistryClient(url, credentials);
     * const repository = client.getRepository(repositoryName);
     * const artifact = repository.getArtifact(digest)
     * for await (const tag of artifact.listTagProperties()) {
     *   console.log("tag: ", tag);
     * }
     * ```
     *
     * Example using `iter.next()`:
     *
     * ```javascript
     * const iter = artifact.listTagProperties();
     * let item = await iter.next();
     * while (!item.done) {
     *   console.log("tag properties: ", item.value);
     *   item = await iter.next();
     * }
     * ```
     *
     * Example using `byPage()`:
     *
     * ```javascript
     * const pages = artifact.listTagProperties().byPage({ maxPageSize: 2 });
     * let page = await pages.next();
     * let i = 1;
     * while (!page.done) {
     *  if (page.value) {
     *    console.log(`-- page ${i++}`);
     *    for (const tagProperties of page.value) {
     *      console.log(`  repository name: ${tagProperties}`);
     *    }
     *  }
     *  page = await pages.next();
     * }
     * ```
     * @param options -
     */
    listTagProperties(options = {}) {
        const iter = this.listTagsItems(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings = {}) => this.listTagsPage(settings, options),
        };
    }
    listTagsItems(options = {}) {
        return tslib.__asyncGenerator(this, arguments, function* listTagsItems_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listTagsPage({}, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    listTagsPage(continuationState, options = {}) {
        return tslib.__asyncGenerator(this, arguments, function* listTagsPage_1() {
            const orderby = toServiceTagOrderBy(options.order);
            if (!continuationState.continuationToken) {
                const optionsComplete = Object.assign(Object.assign({}, options), { n: continuationState.maxPageSize, orderby });
                const currentPage = yield tslib.__await(this.client.containerRegistry.getTags(this.repositoryName, optionsComplete));
                continuationState.continuationToken = extractNextLink(currentPage.link);
                if (currentPage.tagAttributeBases) {
                    const array = currentPage.tagAttributeBases.map((t) => {
                        return Object.assign({ registryLoginServer: currentPage.registryLoginServer, repositoryName: currentPage.repository }, t);
                    });
                    yield yield tslib.__await(Object.defineProperty(array, "continuationToken", {
                        value: continuationState.continuationToken,
                        enumerable: true,
                    }));
                }
            }
            while (continuationState.continuationToken) {
                const currentPage = yield tslib.__await(this.client.containerRegistry.getTagsNext(this.repositoryName, continuationState.continuationToken, options));
                continuationState.continuationToken = extractNextLink(currentPage.link);
                if (currentPage.tagAttributeBases) {
                    const array = currentPage.tagAttributeBases.map((t) => {
                        return Object.assign({ registryLoginServer: currentPage.registryLoginServer, repositoryName: currentPage.repository }, t);
                    });
                    yield yield tslib.__await(Object.defineProperty(array, "continuationToken", {
                        value: continuationState.continuationToken,
                        enumerable: true,
                    }));
                }
            }
        });
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * The client class used to interact with the Container Registry service.
 * @internal
 */
class ContainerRepositoryImpl {
    /**
     * Creates an instance of a ContainerRepository.
     * @param registryEndpoint - the URL to the Container Registry endpoint
     * @param name - the name of the repository
     * @param client - the generated client that interacts with service
     */
    constructor(registryEndpoint, name, client) {
        this.registryEndpoint = registryEndpoint;
        this.name = name;
        this.client = client;
    }
    /**
     * Deletes this repository and all artifacts that are part of its logical group.
     *
     * @param options - optional configuration for the operation
     */
    async delete(options = {}) {
        const { span, updatedOptions } = createSpan("ContainerRepository-delete", options);
        try {
            await this.client.containerRegistry.deleteRepository(this.name, updatedOptions);
        }
        catch (e) {
            span.setStatus({ code: coreTracing.SpanStatusCode.ERROR, message: e.message });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Returns an helper instance of {@link RegistryArtifact} for the given tag or digest.
     * @param tagOrDigest - the tag or digest of the artifact
     */
    getArtifact(tagOrDigest) {
        if (!tagOrDigest) {
            throw new Error("invalid tagOrDigest");
        }
        return new RegistryArtifactImpl(this.registryEndpoint, this.name, tagOrDigest, this.client);
    }
    /**
     * Retrieves the properties of this repository.
     * @param options -
     */
    async getProperties(options = {}) {
        const { span, updatedOptions } = createSpan("ContainerRepository-getProperties", options);
        try {
            return await this.client.containerRegistry.getProperties(this.name, updatedOptions);
        }
        catch (e) {
            span.setStatus({ code: coreTracing.SpanStatusCode.ERROR, message: e.message });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Updates the properties of this repository.
     *
     * Example usage:
     *
     * ```javascript
     * const client = new ContainerRegistryClient(url, credential);
     * const repository = client.getRepository(repositoryName)
     * const updated = await repository.updateProperties({
     *   canDelete: false,
     *   canList: false,
     *   canRead: false,
     *   canWrite: false
     * });
     * ```
     * @param options -
     */
    async updateProperties(options) {
        const value = {
            canDelete: options.canDelete,
            canWrite: options.canWrite,
            canList: options.canList,
            canRead: options.canRead,
        };
        const { span, updatedOptions } = createSpan("ContainerRepository-updateProperties", Object.assign(Object.assign({}, options), { value }));
        try {
            return await this.client.containerRegistry.updateProperties(this.name, updatedOptions);
        }
        catch (e) {
            span.setStatus({ code: coreTracing.SpanStatusCode.ERROR, message: e.message });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Returns an async iterable iterator to list manifest properties.
     * This is useful for determining the collection of artifacts associated with
     * this repository, as each artifact is uniquely identified by its manifest.
     *
     * Example using `for-await-of` syntax:
     *
     * ```javascript
     * const client = new ContainerRegistryClient(url, credential);
     * const repository = client.getRepository(repositoryName)
     * for await (const manifest of repository.listManifestProperties()) {
     *   console.log("manifest: ", manifest);
     * }
     * ```
     *
     * Example using `iter.next()`:
     *
     * ```javascript
     * const iter = repository.listManifestProperties();
     * let item = await iter.next();
     * while (!item.done) {
     *   console.log("manifest properties: ", item.value);
     *   item = await iter.next();
     * }
     * ```
     *
     * Example using `byPage()`:
     *
     * ```javascript
     * const pages = repository.listManifestProperties().byPage({ maxPageSize: 2 });
     * let page = await pages.next();
     * let i = 1;
     * while (!page.done) {
     *  if (page.value) {
     *    console.log(`-- page ${i++}`);
     *    for (const manifestProperties of page.value) {
     *      console.log(`  manifest properties: ${manifestProperties}`);
     *    }
     *  }
     *  page = await pages.next();
     * }
     * ```
     * @param options -
     */
    listManifestProperties(options = {}) {
        const iter = this.listManifestsItems(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings = {}) => this.listManifestsPage(settings, options),
        };
    }
    listManifestsItems(options = {}) {
        return tslib.__asyncGenerator(this, arguments, function* listManifestsItems_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listManifestsPage({}, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    listManifestsPage(continuationState, options = {}) {
        return tslib.__asyncGenerator(this, arguments, function* listManifestsPage_1() {
            const orderby = toServiceManifestOrderBy(options.order);
            if (!continuationState.continuationToken) {
                const optionsComplete = Object.assign(Object.assign({}, options), { n: continuationState.maxPageSize, orderby });
                const currentPage = yield tslib.__await(this.client.containerRegistry.getManifests(this.name, optionsComplete));
                continuationState.continuationToken = extractNextLink(currentPage.link);
                if (currentPage.manifests) {
                    const array = currentPage.manifests.map((t) => toArtifactManifestProperties(t, this.name, currentPage.registryLoginServer));
                    yield yield tslib.__await(Object.defineProperty(array, "continuationToken", {
                        value: continuationState.continuationToken,
                        enumerable: true,
                    }));
                }
            }
            while (continuationState.continuationToken) {
                const currentPage = yield tslib.__await(this.client.containerRegistry.getManifestsNext(this.name, continuationState.continuationToken, options));
                continuationState.continuationToken = extractNextLink(currentPage.link);
                if (currentPage.manifests) {
                    const array = currentPage.manifests.map((t) => toArtifactManifestProperties(t, this.name, currentPage.registryLoginServer));
                    yield yield tslib.__await(Object.defineProperty(array, "continuationToken", {
                        value: continuationState.continuationToken,
                        enumerable: true,
                    }));
                }
            }
        });
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Base64 decode
 *
 * @internal
 * @param encodedString -
 * @returns
 */
function base64decode(encodedString) {
    return Buffer.from(encodedString, "base64").toString();
}

// Copyright (c) Microsoft Corporation.
class ContainerRegistryRefreshTokenCredential {
    constructor(authClient, authenticationScope, credential) {
        this.authenticationScope = authenticationScope;
        this.credential = credential;
        this.tokenService = new ContainerRegistryTokenService(authClient);
        this.isAnonymousAccess = !this.credential;
    }
    async getToken(_scopes, options) {
        if (!this.credential) {
            return null;
        }
        const aadToken = await this.credential.getToken(this.authenticationScope, options);
        if (!aadToken) {
            throw new Error("Failed to retrieve AAD token.");
        }
        return this.tokenService.ExchangeAadAccessTokenForAcrRefreshTokenAsync(aadToken.token, options.service, options);
    }
}
class ContainerRegistryTokenService {
    constructor(authClient) {
        this.authClient = authClient;
    }
    async ExchangeAadAccessTokenForAcrRefreshTokenAsync(aadAccessToken, service, options) {
        const acrRefreshToken = await this.authClient.authentication.exchangeAadAccessTokenForAcrRefreshToken("access_token", service, Object.assign(Object.assign({}, options), { accessToken: aadAccessToken }));
        if (!acrRefreshToken.refreshToken) {
            throw new Error("Failed to exchange AAD access token for an ACR refresh token.");
        }
        // ACR refresh token expires after three hours
        const jwtParts = acrRefreshToken.refreshToken.split(".");
        if (jwtParts.length < 3) {
            throw new Error("Invalid JWT structure from ACR refresh token.");
        }
        if (!jwtParts[1]) {
            throw new Error("Invalid JWT payload.");
        }
        const jwtPayload = JSON.parse(base64decode(jwtParts[1]));
        if (!jwtPayload.exp) {
            throw new Error("Invalid JWT payload structure. No expiration.");
        }
        // JWT expiry is in seconds
        const expiry = Number.parseInt(jwtPayload.exp) * 1000;
        return {
            token: acrRefreshToken.refreshToken,
            expiresOnTimestamp: expiry,
        };
    }
    async ExchangeAcrRefreshTokenForAcrAccessTokenAsync(acrRefreshToken, service, scope, grantType, options) {
        const acrAccessToken = await this.authClient.authentication.exchangeAcrRefreshTokenForAcrAccessToken(service, scope, acrRefreshToken, grantType, options);
        if (!acrAccessToken.accessToken) {
            throw new Error("Failed to exchange ACR refresh token for an ACR access token");
        }
        return acrAccessToken.accessToken;
    }
}

// Copyright (c) Microsoft Corporation.
const LATEST_API_VERSION = "2021-07-01";
/**
 * The client class used to interact with the Container Registry service.
 */
class ContainerRegistryClient {
    constructor(endpoint, credentialOrOptions, clientOptions = {}) {
        var _a;
        if (!endpoint) {
            throw new Error("invalid endpoint");
        }
        this.endpoint = endpoint;
        let credential;
        let options;
        if (coreAuth.isTokenCredential(credentialOrOptions)) {
            credential = credentialOrOptions;
            options = clientOptions;
        }
        else {
            options = credentialOrOptions !== null && credentialOrOptions !== void 0 ? credentialOrOptions : {};
        }
        const internalPipelineOptions = Object.assign(Object.assign({}, options), { loggingOptions: {
                logger: logger.info,
                // This array contains header names we want to log that are not already
                // included as safe. Unknown/unsafe headers are logged as "<REDACTED>".
                additionalAllowedQueryParameters: ["last", "n", "orderby", "digest"],
            } });
        // Require audience now until we have a default ACR audience from the service.
        if (!options.audience) {
            throw new Error("ContainerRegistryClientOptions.audience must be set to initialize ContainerRegistryClient.");
        }
        const defaultScope = `${options.audience}/.default`;
        const serviceVersion = (_a = options.serviceVersion) !== null && _a !== void 0 ? _a : LATEST_API_VERSION;
        const authClient = new GeneratedClient(endpoint, serviceVersion, internalPipelineOptions);
        this.client = new GeneratedClient(endpoint, serviceVersion, internalPipelineOptions);
        this.client.pipeline.addPolicy(coreRestPipeline.bearerTokenAuthenticationPolicy({
            credential,
            scopes: [defaultScope],
            challengeCallbacks: new ChallengeHandler(new ContainerRegistryRefreshTokenCredential(authClient, defaultScope, credential)),
        }));
    }
    /**
     * Deletes the repository identified by the given name and all associated artifacts.
     *
     * @param repositoryName - the name of repository to delete
     * @param options - optional configuration for the operation
     */
    async deleteRepository(repositoryName, options = {}) {
        if (!repositoryName) {
            throw new Error("invalid repositoryName");
        }
        const { span, updatedOptions } = createSpan("ContainerRegistryClient-deleteRepository", options);
        try {
            await this.client.containerRegistry.deleteRepository(repositoryName, updatedOptions);
        }
        catch (e) {
            span.setStatus({ code: coreTracing.SpanStatusCode.ERROR, message: e.message });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Returns an instance of {@link RegistryArtifact} for calling service methods related to the artifact specified by `repositoryName` and `tagOrDigest`.
     *
     * @param repositoryName - the name of repository
     * @param tagOrDigest - tag or digest of the artifact to retrieve
     */
    getArtifact(repositoryName, tagOrDigest) {
        if (!repositoryName) {
            throw new Error("invalid repositoryName");
        }
        if (!tagOrDigest) {
            throw new Error("invalid tagOrDigest");
        }
        return new ContainerRepositoryImpl(this.endpoint, repositoryName, this.client).getArtifact(tagOrDigest);
    }
    /**
     * Returns an instance of {@link ContainerRepository} for calling service methods related to the repository specified by `repositoryName`.
     *
     * @param repositoryName - the name of repository
     */
    getRepository(repositoryName) {
        if (!repositoryName) {
            throw new Error("invalid repositoryName");
        }
        return new ContainerRepositoryImpl(this.endpoint, repositoryName, this.client);
    }
    /**
     * Returns an async iterable iterator to list names of repositories in this registry.
     *
     * Example usage:
     * ```javascript
     * let client = new ContainerRegistryClient(url, credential);
     * for await (const repository of client.listRepositoryNames()) {
     *   console.log("repository name: ", repository);
     * }
     * ```
     *
     * Example using `iter.next()`:
     *
     * ```javascript
     * let iter = client.listRepositoryNames();
     * let item = await iter.next();
     * while (!item.done) {
     *   console.log(`repository name: ${item.value}`);
     *   item = await iter.next();
     * }
     * ```
     *
     * Example using `byPage()`:
     *
     * ```javascript
     * const pages = client.listRepositoryNames().byPage({ maxPageSize: 2 });
     * let page = await pages.next();
     * let i = 1;
     * while (!page.done) {
     *  if (page.value) {
     *    console.log(`-- page ${i++}`);
     *    for (const name of page.value) {
     *      console.log(`  repository name: ${name}`);
     *    }
     *  }
     *  page = await pages.next();
     * }
     * ```
     * @param options -
     */
    listRepositoryNames(options = {}) {
        const iter = this.listRepositoryItems(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings = {}) => this.listRepositoriesPage(settings, options),
        };
    }
    listRepositoryItems(options = {}) {
        return tslib.__asyncGenerator(this, arguments, function* listRepositoryItems_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listRepositoriesPage({}, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    listRepositoriesPage(continuationState, options = {}) {
        return tslib.__asyncGenerator(this, arguments, function* listRepositoriesPage_1() {
            if (!continuationState.continuationToken) {
                const optionsComplete = Object.assign(Object.assign({}, options), { n: continuationState.maxPageSize });
                const currentPage = yield tslib.__await(this.client.containerRegistry.getRepositories(optionsComplete));
                continuationState.continuationToken = extractNextLink(currentPage.link);
                if (currentPage.repositories) {
                    const array = currentPage.repositories;
                    yield yield tslib.__await(Object.defineProperty(array, "continuationToken", {
                        value: continuationState.continuationToken,
                        enumerable: true,
                    }));
                }
            }
            while (continuationState.continuationToken) {
                const currentPage = yield tslib.__await(this.client.containerRegistry.getRepositoriesNext(continuationState.continuationToken, options));
                continuationState.continuationToken = extractNextLink(currentPage.link);
                if (currentPage.repositories) {
                    const array = currentPage.repositories;
                    yield yield tslib.__await(Object.defineProperty(array, "continuationToken", {
                        value: continuationState.continuationToken,
                        enumerable: true,
                    }));
                }
            }
        });
    }
}

// Copyright (c) Microsoft Corporation.
(function (KnownContainerRegistryAudience) {
    /** Azure China */
    KnownContainerRegistryAudience["AzureResourceManagerChina"] = "https://management.chinacloudapi.cn";
    /** Azure Gemany */
    KnownContainerRegistryAudience["AzureResourceManagerGermany"] = "https://management.microsoftazure.de";
    /** Azure Government */
    KnownContainerRegistryAudience["AzureResourceManagerGovernment"] = "https://management.usgovcloudapi.net";
    /** Azure Public Cloud */
    KnownContainerRegistryAudience["AzureResourceManagerPublicCloud"] = "https://management.azure.com";
})(exports.KnownContainerRegistryAudience || (exports.KnownContainerRegistryAudience = {}));
(function (KnownArtifactArchitecture) {
    /** i386 */
    KnownArtifactArchitecture["I386"] = "386";
    /** AMD64 */
    KnownArtifactArchitecture["Amd64"] = "amd64";
    /** ARM */
    KnownArtifactArchitecture["Arm"] = "arm";
    /** ARM64 */
    KnownArtifactArchitecture["Arm64"] = "arm64";
    /** MIPS */
    KnownArtifactArchitecture["Mips"] = "mips";
    /** MIPSLE */
    KnownArtifactArchitecture["MipsLe"] = "mipsle";
    /** MIPS64 */
    KnownArtifactArchitecture["Mips64"] = "mips64";
    /** MIPS64LE */
    KnownArtifactArchitecture["Mips64Le"] = "mips64le";
    /** PPC64 */
    KnownArtifactArchitecture["Ppc64"] = "ppc64";
    /** PPC64LE */
    KnownArtifactArchitecture["Ppc64Le"] = "ppc64le";
    /** RISCv64 */
    KnownArtifactArchitecture["RiscV64"] = "riscv64";
    /** s390x */
    KnownArtifactArchitecture["S390X"] = "s390x";
    /** Wasm */
    KnownArtifactArchitecture["Wasm"] = "wasm";
})(exports.KnownArtifactArchitecture || (exports.KnownArtifactArchitecture = {}));
(function (KnownArtifactOperatingSystem) {
    /** Aix */
    KnownArtifactOperatingSystem["Aix"] = "aix";
    /** Android */
    KnownArtifactOperatingSystem["Android"] = "android";
    /** Darwin */
    KnownArtifactOperatingSystem["Darwin"] = "darwin";
    /** Dragonfly */
    KnownArtifactOperatingSystem["Dragonfly"] = "dragonfly";
    /** FreeBSD */
    KnownArtifactOperatingSystem["FreeBsd"] = "freebsd";
    /** Illumos */
    KnownArtifactOperatingSystem["Illumos"] = "illumos";
    /** iOS */
    KnownArtifactOperatingSystem["iOS"] = "ios";
    /** JS */
    KnownArtifactOperatingSystem["JS"] = "js";
    /** Linux */
    KnownArtifactOperatingSystem["Linux"] = "linux";
    /** NetBSD */
    KnownArtifactOperatingSystem["NetBsd"] = "netbsd";
    /** OpenBSD */
    KnownArtifactOperatingSystem["OpenBsd"] = "openbsd";
    /** Plan9 */
    KnownArtifactOperatingSystem["Plan9"] = "plan9";
    /** Solaris */
    KnownArtifactOperatingSystem["Solaris"] = "solaris";
    /** Windows */
    KnownArtifactOperatingSystem["Windows"] = "windows";
})(exports.KnownArtifactOperatingSystem || (exports.KnownArtifactOperatingSystem = {}));

exports.ContainerRegistryClient = ContainerRegistryClient;
//# sourceMappingURL=index.js.map
