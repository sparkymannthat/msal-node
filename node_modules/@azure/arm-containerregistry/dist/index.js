'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var coreClient = require('@azure/core-client');
var tslib = require('tslib');
var coreLro = require('@azure/core-lro');

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
(function (KnownImportMode) {
    KnownImportMode["NoForce"] = "NoForce";
    KnownImportMode["Force"] = "Force";
})(exports.KnownImportMode || (exports.KnownImportMode = {}));
(function (KnownConnectionStatus) {
    KnownConnectionStatus["Approved"] = "Approved";
    KnownConnectionStatus["Pending"] = "Pending";
    KnownConnectionStatus["Rejected"] = "Rejected";
    KnownConnectionStatus["Disconnected"] = "Disconnected";
})(exports.KnownConnectionStatus || (exports.KnownConnectionStatus = {}));
(function (KnownActionsRequired) {
    KnownActionsRequired["None"] = "None";
    KnownActionsRequired["Recreate"] = "Recreate";
})(exports.KnownActionsRequired || (exports.KnownActionsRequired = {}));
(function (KnownProvisioningState) {
    KnownProvisioningState["Creating"] = "Creating";
    KnownProvisioningState["Updating"] = "Updating";
    KnownProvisioningState["Deleting"] = "Deleting";
    KnownProvisioningState["Succeeded"] = "Succeeded";
    KnownProvisioningState["Failed"] = "Failed";
    KnownProvisioningState["Canceled"] = "Canceled";
})(exports.KnownProvisioningState || (exports.KnownProvisioningState = {}));
(function (KnownCreatedByType) {
    KnownCreatedByType["User"] = "User";
    KnownCreatedByType["Application"] = "Application";
    KnownCreatedByType["ManagedIdentity"] = "ManagedIdentity";
    KnownCreatedByType["Key"] = "Key";
})(exports.KnownCreatedByType || (exports.KnownCreatedByType = {}));
(function (KnownLastModifiedByType) {
    KnownLastModifiedByType["User"] = "User";
    KnownLastModifiedByType["Application"] = "Application";
    KnownLastModifiedByType["ManagedIdentity"] = "ManagedIdentity";
    KnownLastModifiedByType["Key"] = "Key";
})(exports.KnownLastModifiedByType || (exports.KnownLastModifiedByType = {}));
(function (KnownSkuName) {
    KnownSkuName["Classic"] = "Classic";
    KnownSkuName["Basic"] = "Basic";
    KnownSkuName["Standard"] = "Standard";
    KnownSkuName["Premium"] = "Premium";
})(exports.KnownSkuName || (exports.KnownSkuName = {}));
(function (KnownSkuTier) {
    KnownSkuTier["Classic"] = "Classic";
    KnownSkuTier["Basic"] = "Basic";
    KnownSkuTier["Standard"] = "Standard";
    KnownSkuTier["Premium"] = "Premium";
})(exports.KnownSkuTier || (exports.KnownSkuTier = {}));
(function (KnownDefaultAction) {
    KnownDefaultAction["Allow"] = "Allow";
    KnownDefaultAction["Deny"] = "Deny";
})(exports.KnownDefaultAction || (exports.KnownDefaultAction = {}));
(function (KnownAction) {
    KnownAction["Allow"] = "Allow";
})(exports.KnownAction || (exports.KnownAction = {}));
(function (KnownPolicyStatus) {
    KnownPolicyStatus["Enabled"] = "enabled";
    KnownPolicyStatus["Disabled"] = "disabled";
})(exports.KnownPolicyStatus || (exports.KnownPolicyStatus = {}));
(function (KnownTrustPolicyType) {
    KnownTrustPolicyType["Notary"] = "Notary";
})(exports.KnownTrustPolicyType || (exports.KnownTrustPolicyType = {}));
(function (KnownExportPolicyStatus) {
    KnownExportPolicyStatus["Enabled"] = "enabled";
    KnownExportPolicyStatus["Disabled"] = "disabled";
})(exports.KnownExportPolicyStatus || (exports.KnownExportPolicyStatus = {}));
(function (KnownEncryptionStatus) {
    KnownEncryptionStatus["Enabled"] = "enabled";
    KnownEncryptionStatus["Disabled"] = "disabled";
})(exports.KnownEncryptionStatus || (exports.KnownEncryptionStatus = {}));
(function (KnownPublicNetworkAccess) {
    KnownPublicNetworkAccess["Enabled"] = "Enabled";
    KnownPublicNetworkAccess["Disabled"] = "Disabled";
})(exports.KnownPublicNetworkAccess || (exports.KnownPublicNetworkAccess = {}));
(function (KnownNetworkRuleBypassOptions) {
    KnownNetworkRuleBypassOptions["AzureServices"] = "AzureServices";
    KnownNetworkRuleBypassOptions["None"] = "None";
})(exports.KnownNetworkRuleBypassOptions || (exports.KnownNetworkRuleBypassOptions = {}));
(function (KnownZoneRedundancy) {
    KnownZoneRedundancy["Enabled"] = "Enabled";
    KnownZoneRedundancy["Disabled"] = "Disabled";
})(exports.KnownZoneRedundancy || (exports.KnownZoneRedundancy = {}));
(function (KnownRegistryUsageUnit) {
    KnownRegistryUsageUnit["Count"] = "Count";
    KnownRegistryUsageUnit["Bytes"] = "Bytes";
})(exports.KnownRegistryUsageUnit || (exports.KnownRegistryUsageUnit = {}));
(function (KnownWebhookStatus) {
    KnownWebhookStatus["Enabled"] = "enabled";
    KnownWebhookStatus["Disabled"] = "disabled";
})(exports.KnownWebhookStatus || (exports.KnownWebhookStatus = {}));
(function (KnownWebhookAction) {
    KnownWebhookAction["Push"] = "push";
    KnownWebhookAction["Delete"] = "delete";
    KnownWebhookAction["Quarantine"] = "quarantine";
    KnownWebhookAction["ChartPush"] = "chart_push";
    KnownWebhookAction["ChartDelete"] = "chart_delete";
})(exports.KnownWebhookAction || (exports.KnownWebhookAction = {}));
(function (KnownOS) {
    KnownOS["Windows"] = "Windows";
    KnownOS["Linux"] = "Linux";
})(exports.KnownOS || (exports.KnownOS = {}));
(function (KnownRunStatus) {
    KnownRunStatus["Queued"] = "Queued";
    KnownRunStatus["Started"] = "Started";
    KnownRunStatus["Running"] = "Running";
    KnownRunStatus["Succeeded"] = "Succeeded";
    KnownRunStatus["Failed"] = "Failed";
    KnownRunStatus["Canceled"] = "Canceled";
    KnownRunStatus["Error"] = "Error";
    KnownRunStatus["Timeout"] = "Timeout";
})(exports.KnownRunStatus || (exports.KnownRunStatus = {}));
(function (KnownRunType) {
    KnownRunType["QuickBuild"] = "QuickBuild";
    KnownRunType["QuickRun"] = "QuickRun";
    KnownRunType["AutoBuild"] = "AutoBuild";
    KnownRunType["AutoRun"] = "AutoRun";
})(exports.KnownRunType || (exports.KnownRunType = {}));
(function (KnownArchitecture) {
    KnownArchitecture["Amd64"] = "amd64";
    KnownArchitecture["X86"] = "x86";
    KnownArchitecture["ThreeHundredEightySix"] = "386";
    KnownArchitecture["Arm"] = "arm";
    KnownArchitecture["Arm64"] = "arm64";
})(exports.KnownArchitecture || (exports.KnownArchitecture = {}));
(function (KnownVariant) {
    KnownVariant["V6"] = "v6";
    KnownVariant["V7"] = "v7";
    KnownVariant["V8"] = "v8";
})(exports.KnownVariant || (exports.KnownVariant = {}));
(function (KnownTaskStatus) {
    KnownTaskStatus["Disabled"] = "Disabled";
    KnownTaskStatus["Enabled"] = "Enabled";
})(exports.KnownTaskStatus || (exports.KnownTaskStatus = {}));
(function (KnownStepType) {
    KnownStepType["Docker"] = "Docker";
    KnownStepType["FileTask"] = "FileTask";
    KnownStepType["EncodedTask"] = "EncodedTask";
})(exports.KnownStepType || (exports.KnownStepType = {}));
(function (KnownBaseImageDependencyType) {
    KnownBaseImageDependencyType["BuildTime"] = "BuildTime";
    KnownBaseImageDependencyType["RunTime"] = "RunTime";
})(exports.KnownBaseImageDependencyType || (exports.KnownBaseImageDependencyType = {}));
(function (KnownTriggerStatus) {
    KnownTriggerStatus["Disabled"] = "Disabled";
    KnownTriggerStatus["Enabled"] = "Enabled";
})(exports.KnownTriggerStatus || (exports.KnownTriggerStatus = {}));
(function (KnownSourceControlType) {
    KnownSourceControlType["Github"] = "Github";
    KnownSourceControlType["VisualStudioTeamService"] = "VisualStudioTeamService";
})(exports.KnownSourceControlType || (exports.KnownSourceControlType = {}));
(function (KnownTokenType) {
    KnownTokenType["PAT"] = "PAT";
    KnownTokenType["OAuth"] = "OAuth";
})(exports.KnownTokenType || (exports.KnownTokenType = {}));
(function (KnownSourceTriggerEvent) {
    KnownSourceTriggerEvent["Commit"] = "commit";
    KnownSourceTriggerEvent["Pullrequest"] = "pullrequest";
})(exports.KnownSourceTriggerEvent || (exports.KnownSourceTriggerEvent = {}));
(function (KnownBaseImageTriggerType) {
    KnownBaseImageTriggerType["All"] = "All";
    KnownBaseImageTriggerType["Runtime"] = "Runtime";
})(exports.KnownBaseImageTriggerType || (exports.KnownBaseImageTriggerType = {}));
(function (KnownUpdateTriggerPayloadType) {
    KnownUpdateTriggerPayloadType["Default"] = "Default";
    KnownUpdateTriggerPayloadType["Token"] = "Token";
})(exports.KnownUpdateTriggerPayloadType || (exports.KnownUpdateTriggerPayloadType = {}));
(function (KnownSourceRegistryLoginMode) {
    KnownSourceRegistryLoginMode["None"] = "None";
    KnownSourceRegistryLoginMode["Default"] = "Default";
})(exports.KnownSourceRegistryLoginMode || (exports.KnownSourceRegistryLoginMode = {}));
(function (KnownSecretObjectType) {
    KnownSecretObjectType["Opaque"] = "Opaque";
    KnownSecretObjectType["Vaultsecret"] = "Vaultsecret";
})(exports.KnownSecretObjectType || (exports.KnownSecretObjectType = {}));

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const ImportImageParameters = {
    type: {
        name: "Composite",
        className: "ImportImageParameters",
        modelProperties: {
            source: {
                serializedName: "source",
                type: {
                    name: "Composite",
                    className: "ImportSource"
                }
            },
            targetTags: {
                serializedName: "targetTags",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            untaggedTargetRepositories: {
                serializedName: "untaggedTargetRepositories",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            mode: {
                defaultValue: "NoForce",
                serializedName: "mode",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ImportSource = {
    type: {
        name: "Composite",
        className: "ImportSource",
        modelProperties: {
            resourceId: {
                serializedName: "resourceId",
                type: {
                    name: "String"
                }
            },
            registryUri: {
                serializedName: "registryUri",
                type: {
                    name: "String"
                }
            },
            credentials: {
                serializedName: "credentials",
                type: {
                    name: "Composite",
                    className: "ImportSourceCredentials"
                }
            },
            sourceImage: {
                serializedName: "sourceImage",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ImportSourceCredentials = {
    type: {
        name: "Composite",
        className: "ImportSourceCredentials",
        modelProperties: {
            username: {
                serializedName: "username",
                type: {
                    name: "String"
                }
            },
            password: {
                serializedName: "password",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const OperationListResult = {
    type: {
        name: "Composite",
        className: "OperationListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "OperationDefinition"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const OperationDefinition = {
    type: {
        name: "Composite",
        className: "OperationDefinition",
        modelProperties: {
            origin: {
                serializedName: "origin",
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            display: {
                serializedName: "display",
                type: {
                    name: "Composite",
                    className: "OperationDisplayDefinition"
                }
            },
            isDataAction: {
                serializedName: "isDataAction",
                type: {
                    name: "Boolean"
                }
            },
            serviceSpecification: {
                serializedName: "properties.serviceSpecification",
                type: {
                    name: "Composite",
                    className: "OperationServiceSpecificationDefinition"
                }
            }
        }
    }
};
const OperationDisplayDefinition = {
    type: {
        name: "Composite",
        className: "OperationDisplayDefinition",
        modelProperties: {
            provider: {
                serializedName: "provider",
                type: {
                    name: "String"
                }
            },
            resource: {
                serializedName: "resource",
                type: {
                    name: "String"
                }
            },
            operation: {
                serializedName: "operation",
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const OperationServiceSpecificationDefinition = {
    type: {
        name: "Composite",
        className: "OperationServiceSpecificationDefinition",
        modelProperties: {
            metricSpecifications: {
                serializedName: "metricSpecifications",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "OperationMetricSpecificationDefinition"
                        }
                    }
                }
            },
            logSpecifications: {
                serializedName: "logSpecifications",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "OperationLogSpecificationDefinition"
                        }
                    }
                }
            }
        }
    }
};
const OperationMetricSpecificationDefinition = {
    type: {
        name: "Composite",
        className: "OperationMetricSpecificationDefinition",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            displayName: {
                serializedName: "displayName",
                type: {
                    name: "String"
                }
            },
            displayDescription: {
                serializedName: "displayDescription",
                type: {
                    name: "String"
                }
            },
            unit: {
                serializedName: "unit",
                type: {
                    name: "String"
                }
            },
            aggregationType: {
                serializedName: "aggregationType",
                type: {
                    name: "String"
                }
            },
            internalMetricName: {
                serializedName: "internalMetricName",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const OperationLogSpecificationDefinition = {
    type: {
        name: "Composite",
        className: "OperationLogSpecificationDefinition",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            displayName: {
                serializedName: "displayName",
                type: {
                    name: "String"
                }
            },
            blobDuration: {
                serializedName: "blobDuration",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RegistryNameCheckRequest = {
    type: {
        name: "Composite",
        className: "RegistryNameCheckRequest",
        modelProperties: {
            name: {
                constraints: {
                    Pattern: new RegExp("^[a-zA-Z0-9]*$"),
                    MaxLength: 50,
                    MinLength: 5
                },
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            type: {
                defaultValue: "Microsoft.ContainerRegistry/registries",
                isConstant: true,
                serializedName: "type",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RegistryNameStatus = {
    type: {
        name: "Composite",
        className: "RegistryNameStatus",
        modelProperties: {
            nameAvailable: {
                serializedName: "nameAvailable",
                type: {
                    name: "Boolean"
                }
            },
            reason: {
                serializedName: "reason",
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PrivateEndpointConnectionListResult = {
    type: {
        name: "Composite",
        className: "PrivateEndpointConnectionListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PrivateEndpointConnection"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PrivateEndpoint = {
    type: {
        name: "Composite",
        className: "PrivateEndpoint",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PrivateLinkServiceConnectionState = {
    type: {
        name: "Composite",
        className: "PrivateLinkServiceConnectionState",
        modelProperties: {
            status: {
                serializedName: "status",
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            },
            actionsRequired: {
                serializedName: "actionsRequired",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ProxyResource = {
    type: {
        name: "Composite",
        className: "ProxyResource",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            systemData: {
                serializedName: "systemData",
                type: {
                    name: "Composite",
                    className: "SystemData"
                }
            }
        }
    }
};
const SystemData = {
    type: {
        name: "Composite",
        className: "SystemData",
        modelProperties: {
            createdBy: {
                serializedName: "createdBy",
                type: {
                    name: "String"
                }
            },
            createdByType: {
                serializedName: "createdByType",
                type: {
                    name: "String"
                }
            },
            createdAt: {
                serializedName: "createdAt",
                type: {
                    name: "DateTime"
                }
            },
            lastModifiedBy: {
                serializedName: "lastModifiedBy",
                type: {
                    name: "String"
                }
            },
            lastModifiedByType: {
                serializedName: "lastModifiedByType",
                type: {
                    name: "String"
                }
            },
            lastModifiedAt: {
                serializedName: "lastModifiedAt",
                type: {
                    name: "DateTime"
                }
            }
        }
    }
};
const RegistryListResult = {
    type: {
        name: "Composite",
        className: "RegistryListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Registry"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Sku = {
    type: {
        name: "Composite",
        className: "Sku",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            tier: {
                serializedName: "tier",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const IdentityProperties = {
    type: {
        name: "Composite",
        className: "IdentityProperties",
        modelProperties: {
            principalId: {
                serializedName: "principalId",
                type: {
                    name: "String"
                }
            },
            tenantId: {
                serializedName: "tenantId",
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "SystemAssigned",
                        "UserAssigned",
                        "SystemAssigned, UserAssigned",
                        "None"
                    ]
                }
            },
            userAssignedIdentities: {
                serializedName: "userAssignedIdentities",
                type: {
                    name: "Dictionary",
                    value: {
                        type: { name: "Composite", className: "UserIdentityProperties" }
                    }
                }
            }
        }
    }
};
const UserIdentityProperties = {
    type: {
        name: "Composite",
        className: "UserIdentityProperties",
        modelProperties: {
            principalId: {
                serializedName: "principalId",
                type: {
                    name: "String"
                }
            },
            clientId: {
                serializedName: "clientId",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Status = {
    type: {
        name: "Composite",
        className: "Status",
        modelProperties: {
            displayStatus: {
                serializedName: "displayStatus",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            timestamp: {
                serializedName: "timestamp",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }
        }
    }
};
const NetworkRuleSet = {
    type: {
        name: "Composite",
        className: "NetworkRuleSet",
        modelProperties: {
            defaultAction: {
                defaultValue: "Allow",
                serializedName: "defaultAction",
                required: true,
                type: {
                    name: "String"
                }
            },
            ipRules: {
                serializedName: "ipRules",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "IPRule"
                        }
                    }
                }
            }
        }
    }
};
const IPRule = {
    type: {
        name: "Composite",
        className: "IPRule",
        modelProperties: {
            action: {
                defaultValue: "Allow",
                serializedName: "action",
                type: {
                    name: "String"
                }
            },
            iPAddressOrRange: {
                serializedName: "value",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Policies = {
    type: {
        name: "Composite",
        className: "Policies",
        modelProperties: {
            quarantinePolicy: {
                serializedName: "quarantinePolicy",
                type: {
                    name: "Composite",
                    className: "QuarantinePolicy"
                }
            },
            trustPolicy: {
                serializedName: "trustPolicy",
                type: {
                    name: "Composite",
                    className: "TrustPolicy"
                }
            },
            retentionPolicy: {
                serializedName: "retentionPolicy",
                type: {
                    name: "Composite",
                    className: "RetentionPolicy"
                }
            },
            exportPolicy: {
                serializedName: "exportPolicy",
                type: {
                    name: "Composite",
                    className: "ExportPolicy"
                }
            }
        }
    }
};
const QuarantinePolicy = {
    type: {
        name: "Composite",
        className: "QuarantinePolicy",
        modelProperties: {
            status: {
                serializedName: "status",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TrustPolicy = {
    type: {
        name: "Composite",
        className: "TrustPolicy",
        modelProperties: {
            type: {
                defaultValue: "Notary",
                serializedName: "type",
                type: {
                    name: "String"
                }
            },
            status: {
                serializedName: "status",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RetentionPolicy = {
    type: {
        name: "Composite",
        className: "RetentionPolicy",
        modelProperties: {
            days: {
                defaultValue: 7,
                serializedName: "days",
                type: {
                    name: "Number"
                }
            },
            lastUpdatedTime: {
                serializedName: "lastUpdatedTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            status: {
                serializedName: "status",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ExportPolicy = {
    type: {
        name: "Composite",
        className: "ExportPolicy",
        modelProperties: {
            status: {
                defaultValue: "enabled",
                serializedName: "status",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const EncryptionProperty = {
    type: {
        name: "Composite",
        className: "EncryptionProperty",
        modelProperties: {
            status: {
                serializedName: "status",
                type: {
                    name: "String"
                }
            },
            keyVaultProperties: {
                serializedName: "keyVaultProperties",
                type: {
                    name: "Composite",
                    className: "KeyVaultProperties"
                }
            }
        }
    }
};
const KeyVaultProperties = {
    type: {
        name: "Composite",
        className: "KeyVaultProperties",
        modelProperties: {
            keyIdentifier: {
                serializedName: "keyIdentifier",
                type: {
                    name: "String"
                }
            },
            versionedKeyIdentifier: {
                serializedName: "versionedKeyIdentifier",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            identity: {
                serializedName: "identity",
                type: {
                    name: "String"
                }
            },
            keyRotationEnabled: {
                serializedName: "keyRotationEnabled",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            },
            lastKeyRotationTimestamp: {
                serializedName: "lastKeyRotationTimestamp",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }
        }
    }
};
const Resource = {
    type: {
        name: "Composite",
        className: "Resource",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                required: true,
                type: {
                    name: "String"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            systemData: {
                serializedName: "systemData",
                type: {
                    name: "Composite",
                    className: "SystemData"
                }
            }
        }
    }
};
const RegistryUpdateParameters = {
    type: {
        name: "Composite",
        className: "RegistryUpdateParameters",
        modelProperties: {
            identity: {
                serializedName: "identity",
                type: {
                    name: "Composite",
                    className: "IdentityProperties"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            sku: {
                serializedName: "sku",
                type: {
                    name: "Composite",
                    className: "Sku"
                }
            },
            adminUserEnabled: {
                serializedName: "properties.adminUserEnabled",
                type: {
                    name: "Boolean"
                }
            },
            networkRuleSet: {
                serializedName: "properties.networkRuleSet",
                type: {
                    name: "Composite",
                    className: "NetworkRuleSet"
                }
            },
            policies: {
                serializedName: "properties.policies",
                type: {
                    name: "Composite",
                    className: "Policies"
                }
            },
            encryption: {
                serializedName: "properties.encryption",
                type: {
                    name: "Composite",
                    className: "EncryptionProperty"
                }
            },
            dataEndpointEnabled: {
                serializedName: "properties.dataEndpointEnabled",
                type: {
                    name: "Boolean"
                }
            },
            publicNetworkAccess: {
                serializedName: "properties.publicNetworkAccess",
                type: {
                    name: "String"
                }
            },
            networkRuleBypassOptions: {
                serializedName: "properties.networkRuleBypassOptions",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RegistryUsageListResult = {
    type: {
        name: "Composite",
        className: "RegistryUsageListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RegistryUsage"
                        }
                    }
                }
            }
        }
    }
};
const RegistryUsage = {
    type: {
        name: "Composite",
        className: "RegistryUsage",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            limit: {
                serializedName: "limit",
                type: {
                    name: "Number"
                }
            },
            currentValue: {
                serializedName: "currentValue",
                type: {
                    name: "Number"
                }
            },
            unit: {
                serializedName: "unit",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PrivateLinkResourceListResult = {
    type: {
        name: "Composite",
        className: "PrivateLinkResourceListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PrivateLinkResource"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PrivateLinkResource = {
    type: {
        name: "Composite",
        className: "PrivateLinkResource",
        modelProperties: {
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            groupId: {
                serializedName: "properties.groupId",
                type: {
                    name: "String"
                }
            },
            requiredMembers: {
                serializedName: "properties.requiredMembers",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            requiredZoneNames: {
                serializedName: "properties.requiredZoneNames",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const ErrorResponse = {
    type: {
        name: "Composite",
        className: "ErrorResponse",
        modelProperties: {
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "ErrorResponseBody"
                }
            }
        }
    }
};
const ErrorResponseBody = {
    type: {
        name: "Composite",
        className: "ErrorResponseBody",
        modelProperties: {
            code: {
                serializedName: "code",
                required: true,
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                required: true,
                type: {
                    name: "String"
                }
            },
            target: {
                serializedName: "target",
                type: {
                    name: "String"
                }
            },
            details: {
                serializedName: "details",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "InnerErrorDescription"
                        }
                    }
                }
            }
        }
    }
};
const InnerErrorDescription = {
    type: {
        name: "Composite",
        className: "InnerErrorDescription",
        modelProperties: {
            code: {
                serializedName: "code",
                required: true,
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                required: true,
                type: {
                    name: "String"
                }
            },
            target: {
                serializedName: "target",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RegistryListCredentialsResult = {
    type: {
        name: "Composite",
        className: "RegistryListCredentialsResult",
        modelProperties: {
            username: {
                serializedName: "username",
                type: {
                    name: "String"
                }
            },
            passwords: {
                serializedName: "passwords",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RegistryPassword"
                        }
                    }
                }
            }
        }
    }
};
const RegistryPassword = {
    type: {
        name: "Composite",
        className: "RegistryPassword",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "Enum",
                    allowedValues: ["password", "password2"]
                }
            },
            value: {
                serializedName: "value",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RegenerateCredentialParameters = {
    type: {
        name: "Composite",
        className: "RegenerateCredentialParameters",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "Enum",
                    allowedValues: ["password", "password2"]
                }
            }
        }
    }
};
const ReplicationListResult = {
    type: {
        name: "Composite",
        className: "ReplicationListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Replication"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ReplicationUpdateParameters = {
    type: {
        name: "Composite",
        className: "ReplicationUpdateParameters",
        modelProperties: {
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            regionEndpointEnabled: {
                serializedName: "properties.regionEndpointEnabled",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const WebhookListResult = {
    type: {
        name: "Composite",
        className: "WebhookListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Webhook"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const WebhookCreateParameters = {
    type: {
        name: "Composite",
        className: "WebhookCreateParameters",
        modelProperties: {
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            location: {
                serializedName: "location",
                required: true,
                type: {
                    name: "String"
                }
            },
            serviceUri: {
                serializedName: "properties.serviceUri",
                type: {
                    name: "String"
                }
            },
            customHeaders: {
                serializedName: "properties.customHeaders",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            status: {
                serializedName: "properties.status",
                type: {
                    name: "String"
                }
            },
            scope: {
                serializedName: "properties.scope",
                type: {
                    name: "String"
                }
            },
            actions: {
                serializedName: "properties.actions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const WebhookUpdateParameters = {
    type: {
        name: "Composite",
        className: "WebhookUpdateParameters",
        modelProperties: {
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            serviceUri: {
                serializedName: "properties.serviceUri",
                type: {
                    name: "String"
                }
            },
            customHeaders: {
                serializedName: "properties.customHeaders",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            status: {
                serializedName: "properties.status",
                type: {
                    name: "String"
                }
            },
            scope: {
                serializedName: "properties.scope",
                type: {
                    name: "String"
                }
            },
            actions: {
                serializedName: "properties.actions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const EventInfo = {
    type: {
        name: "Composite",
        className: "EventInfo",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const EventListResult = {
    type: {
        name: "Composite",
        className: "EventListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Event"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const EventRequestMessage = {
    type: {
        name: "Composite",
        className: "EventRequestMessage",
        modelProperties: {
            content: {
                serializedName: "content",
                type: {
                    name: "Composite",
                    className: "EventContent"
                }
            },
            headers: {
                serializedName: "headers",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            method: {
                serializedName: "method",
                type: {
                    name: "String"
                }
            },
            requestUri: {
                serializedName: "requestUri",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "version",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const EventContent = {
    type: {
        name: "Composite",
        className: "EventContent",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            timestamp: {
                serializedName: "timestamp",
                type: {
                    name: "DateTime"
                }
            },
            action: {
                serializedName: "action",
                type: {
                    name: "String"
                }
            },
            target: {
                serializedName: "target",
                type: {
                    name: "Composite",
                    className: "Target"
                }
            },
            request: {
                serializedName: "request",
                type: {
                    name: "Composite",
                    className: "Request"
                }
            },
            actor: {
                serializedName: "actor",
                type: {
                    name: "Composite",
                    className: "Actor"
                }
            },
            source: {
                serializedName: "source",
                type: {
                    name: "Composite",
                    className: "Source"
                }
            }
        }
    }
};
const Target = {
    type: {
        name: "Composite",
        className: "Target",
        modelProperties: {
            mediaType: {
                serializedName: "mediaType",
                type: {
                    name: "String"
                }
            },
            size: {
                serializedName: "size",
                type: {
                    name: "Number"
                }
            },
            digest: {
                serializedName: "digest",
                type: {
                    name: "String"
                }
            },
            length: {
                serializedName: "length",
                type: {
                    name: "Number"
                }
            },
            repository: {
                serializedName: "repository",
                type: {
                    name: "String"
                }
            },
            url: {
                serializedName: "url",
                type: {
                    name: "String"
                }
            },
            tag: {
                serializedName: "tag",
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "version",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Request = {
    type: {
        name: "Composite",
        className: "Request",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            addr: {
                serializedName: "addr",
                type: {
                    name: "String"
                }
            },
            host: {
                serializedName: "host",
                type: {
                    name: "String"
                }
            },
            method: {
                serializedName: "method",
                type: {
                    name: "String"
                }
            },
            useragent: {
                serializedName: "useragent",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Actor = {
    type: {
        name: "Composite",
        className: "Actor",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Source = {
    type: {
        name: "Composite",
        className: "Source",
        modelProperties: {
            addr: {
                serializedName: "addr",
                type: {
                    name: "String"
                }
            },
            instanceID: {
                serializedName: "instanceID",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const EventResponseMessage = {
    type: {
        name: "Composite",
        className: "EventResponseMessage",
        modelProperties: {
            content: {
                serializedName: "content",
                type: {
                    name: "String"
                }
            },
            headers: {
                serializedName: "headers",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            reasonPhrase: {
                serializedName: "reasonPhrase",
                type: {
                    name: "String"
                }
            },
            statusCode: {
                serializedName: "statusCode",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "version",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CallbackConfig = {
    type: {
        name: "Composite",
        className: "CallbackConfig",
        modelProperties: {
            serviceUri: {
                serializedName: "serviceUri",
                required: true,
                type: {
                    name: "String"
                }
            },
            customHeaders: {
                serializedName: "customHeaders",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }
        }
    }
};
const AgentPoolUpdateParameters = {
    type: {
        name: "Composite",
        className: "AgentPoolUpdateParameters",
        modelProperties: {
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            count: {
                serializedName: "properties.count",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const AgentPoolListResult = {
    type: {
        name: "Composite",
        className: "AgentPoolListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AgentPool"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AgentPoolQueueStatus = {
    type: {
        name: "Composite",
        className: "AgentPoolQueueStatus",
        modelProperties: {
            count: {
                serializedName: "count",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const RunRequest = {
    type: {
        name: "Composite",
        className: "RunRequest",
        uberParent: "RunRequest",
        polymorphicDiscriminator: {
            serializedName: "type",
            clientName: "type"
        },
        modelProperties: {
            type: {
                serializedName: "type",
                required: true,
                type: {
                    name: "String"
                }
            },
            isArchiveEnabled: {
                defaultValue: false,
                serializedName: "isArchiveEnabled",
                type: {
                    name: "Boolean"
                }
            },
            agentPoolName: {
                serializedName: "agentPoolName",
                type: {
                    name: "String"
                }
            },
            logTemplate: {
                serializedName: "logTemplate",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ImageDescriptor = {
    type: {
        name: "Composite",
        className: "ImageDescriptor",
        modelProperties: {
            registry: {
                serializedName: "registry",
                type: {
                    name: "String"
                }
            },
            repository: {
                serializedName: "repository",
                type: {
                    name: "String"
                }
            },
            tag: {
                serializedName: "tag",
                type: {
                    name: "String"
                }
            },
            digest: {
                serializedName: "digest",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ImageUpdateTrigger = {
    type: {
        name: "Composite",
        className: "ImageUpdateTrigger",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            timestamp: {
                serializedName: "timestamp",
                type: {
                    name: "DateTime"
                }
            },
            images: {
                serializedName: "images",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ImageDescriptor"
                        }
                    }
                }
            }
        }
    }
};
const SourceTriggerDescriptor = {
    type: {
        name: "Composite",
        className: "SourceTriggerDescriptor",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            eventType: {
                serializedName: "eventType",
                type: {
                    name: "String"
                }
            },
            commitId: {
                serializedName: "commitId",
                type: {
                    name: "String"
                }
            },
            pullRequestId: {
                serializedName: "pullRequestId",
                type: {
                    name: "String"
                }
            },
            repositoryUrl: {
                serializedName: "repositoryUrl",
                type: {
                    name: "String"
                }
            },
            branchName: {
                serializedName: "branchName",
                type: {
                    name: "String"
                }
            },
            providerType: {
                serializedName: "providerType",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TimerTriggerDescriptor = {
    type: {
        name: "Composite",
        className: "TimerTriggerDescriptor",
        modelProperties: {
            timerTriggerName: {
                serializedName: "timerTriggerName",
                type: {
                    name: "String"
                }
            },
            scheduleOccurrence: {
                serializedName: "scheduleOccurrence",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PlatformProperties = {
    type: {
        name: "Composite",
        className: "PlatformProperties",
        modelProperties: {
            os: {
                serializedName: "os",
                required: true,
                type: {
                    name: "String"
                }
            },
            architecture: {
                serializedName: "architecture",
                type: {
                    name: "String"
                }
            },
            variant: {
                serializedName: "variant",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AgentProperties = {
    type: {
        name: "Composite",
        className: "AgentProperties",
        modelProperties: {
            cpu: {
                serializedName: "cpu",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const SourceUploadDefinition = {
    type: {
        name: "Composite",
        className: "SourceUploadDefinition",
        modelProperties: {
            uploadUrl: {
                serializedName: "uploadUrl",
                type: {
                    name: "String"
                }
            },
            relativePath: {
                serializedName: "relativePath",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RunListResult = {
    type: {
        name: "Composite",
        className: "RunListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Run"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RunUpdateParameters = {
    type: {
        name: "Composite",
        className: "RunUpdateParameters",
        modelProperties: {
            isArchiveEnabled: {
                serializedName: "isArchiveEnabled",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const RunGetLogResult = {
    type: {
        name: "Composite",
        className: "RunGetLogResult",
        modelProperties: {
            logLink: {
                serializedName: "logLink",
                type: {
                    name: "String"
                }
            },
            logArtifactLink: {
                serializedName: "logArtifactLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TaskRunUpdateParameters = {
    type: {
        name: "Composite",
        className: "TaskRunUpdateParameters",
        modelProperties: {
            identity: {
                serializedName: "identity",
                type: {
                    name: "Composite",
                    className: "IdentityProperties"
                }
            },
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            runRequest: {
                serializedName: "properties.runRequest",
                type: {
                    name: "Composite",
                    className: "RunRequest"
                }
            },
            forceUpdateTag: {
                serializedName: "properties.forceUpdateTag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TaskRunListResult = {
    type: {
        name: "Composite",
        className: "TaskRunListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TaskRun"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TaskListResult = {
    type: {
        name: "Composite",
        className: "TaskListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Task"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TaskStepProperties = {
    type: {
        name: "Composite",
        className: "TaskStepProperties",
        uberParent: "TaskStepProperties",
        polymorphicDiscriminator: {
            serializedName: "type",
            clientName: "type"
        },
        modelProperties: {
            type: {
                serializedName: "type",
                required: true,
                type: {
                    name: "String"
                }
            },
            baseImageDependencies: {
                serializedName: "baseImageDependencies",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "BaseImageDependency"
                        }
                    }
                }
            },
            contextPath: {
                serializedName: "contextPath",
                type: {
                    name: "String"
                }
            },
            contextAccessToken: {
                serializedName: "contextAccessToken",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const BaseImageDependency = {
    type: {
        name: "Composite",
        className: "BaseImageDependency",
        modelProperties: {
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            },
            registry: {
                serializedName: "registry",
                type: {
                    name: "String"
                }
            },
            repository: {
                serializedName: "repository",
                type: {
                    name: "String"
                }
            },
            tag: {
                serializedName: "tag",
                type: {
                    name: "String"
                }
            },
            digest: {
                serializedName: "digest",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TriggerProperties = {
    type: {
        name: "Composite",
        className: "TriggerProperties",
        modelProperties: {
            timerTriggers: {
                serializedName: "timerTriggers",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TimerTrigger"
                        }
                    }
                }
            },
            sourceTriggers: {
                serializedName: "sourceTriggers",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SourceTrigger"
                        }
                    }
                }
            },
            baseImageTrigger: {
                serializedName: "baseImageTrigger",
                type: {
                    name: "Composite",
                    className: "BaseImageTrigger"
                }
            }
        }
    }
};
const TimerTrigger = {
    type: {
        name: "Composite",
        className: "TimerTrigger",
        modelProperties: {
            schedule: {
                serializedName: "schedule",
                required: true,
                type: {
                    name: "String"
                }
            },
            status: {
                serializedName: "status",
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SourceTrigger = {
    type: {
        name: "Composite",
        className: "SourceTrigger",
        modelProperties: {
            sourceRepository: {
                serializedName: "sourceRepository",
                type: {
                    name: "Composite",
                    className: "SourceProperties"
                }
            },
            sourceTriggerEvents: {
                serializedName: "sourceTriggerEvents",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            status: {
                serializedName: "status",
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SourceProperties = {
    type: {
        name: "Composite",
        className: "SourceProperties",
        modelProperties: {
            sourceControlType: {
                serializedName: "sourceControlType",
                required: true,
                type: {
                    name: "String"
                }
            },
            repositoryUrl: {
                serializedName: "repositoryUrl",
                required: true,
                type: {
                    name: "String"
                }
            },
            branch: {
                serializedName: "branch",
                type: {
                    name: "String"
                }
            },
            sourceControlAuthProperties: {
                serializedName: "sourceControlAuthProperties",
                type: {
                    name: "Composite",
                    className: "AuthInfo"
                }
            }
        }
    }
};
const AuthInfo = {
    type: {
        name: "Composite",
        className: "AuthInfo",
        modelProperties: {
            tokenType: {
                serializedName: "tokenType",
                required: true,
                type: {
                    name: "String"
                }
            },
            token: {
                serializedName: "token",
                required: true,
                type: {
                    name: "String"
                }
            },
            refreshToken: {
                serializedName: "refreshToken",
                type: {
                    name: "String"
                }
            },
            scope: {
                serializedName: "scope",
                type: {
                    name: "String"
                }
            },
            expiresIn: {
                serializedName: "expiresIn",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const BaseImageTrigger = {
    type: {
        name: "Composite",
        className: "BaseImageTrigger",
        modelProperties: {
            baseImageTriggerType: {
                serializedName: "baseImageTriggerType",
                required: true,
                type: {
                    name: "String"
                }
            },
            updateTriggerEndpoint: {
                serializedName: "updateTriggerEndpoint",
                type: {
                    name: "String"
                }
            },
            updateTriggerPayloadType: {
                serializedName: "updateTriggerPayloadType",
                type: {
                    name: "String"
                }
            },
            status: {
                serializedName: "status",
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Credentials = {
    type: {
        name: "Composite",
        className: "Credentials",
        modelProperties: {
            sourceRegistry: {
                serializedName: "sourceRegistry",
                type: {
                    name: "Composite",
                    className: "SourceRegistryCredentials"
                }
            },
            customRegistries: {
                serializedName: "customRegistries",
                type: {
                    name: "Dictionary",
                    value: {
                        type: { name: "Composite", className: "CustomRegistryCredentials" }
                    }
                }
            }
        }
    }
};
const SourceRegistryCredentials = {
    type: {
        name: "Composite",
        className: "SourceRegistryCredentials",
        modelProperties: {
            loginMode: {
                serializedName: "loginMode",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CustomRegistryCredentials = {
    type: {
        name: "Composite",
        className: "CustomRegistryCredentials",
        modelProperties: {
            userName: {
                serializedName: "userName",
                type: {
                    name: "Composite",
                    className: "SecretObject"
                }
            },
            password: {
                serializedName: "password",
                type: {
                    name: "Composite",
                    className: "SecretObject"
                }
            },
            identity: {
                serializedName: "identity",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SecretObject = {
    type: {
        name: "Composite",
        className: "SecretObject",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TaskUpdateParameters = {
    type: {
        name: "Composite",
        className: "TaskUpdateParameters",
        modelProperties: {
            identity: {
                serializedName: "identity",
                type: {
                    name: "Composite",
                    className: "IdentityProperties"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            status: {
                serializedName: "properties.status",
                type: {
                    name: "String"
                }
            },
            platform: {
                serializedName: "properties.platform",
                type: {
                    name: "Composite",
                    className: "PlatformUpdateParameters"
                }
            },
            agentConfiguration: {
                serializedName: "properties.agentConfiguration",
                type: {
                    name: "Composite",
                    className: "AgentProperties"
                }
            },
            agentPoolName: {
                serializedName: "properties.agentPoolName",
                type: {
                    name: "String"
                }
            },
            timeout: {
                serializedName: "properties.timeout",
                type: {
                    name: "Number"
                }
            },
            step: {
                serializedName: "properties.step",
                type: {
                    name: "Composite",
                    className: "TaskStepUpdateParameters"
                }
            },
            trigger: {
                serializedName: "properties.trigger",
                type: {
                    name: "Composite",
                    className: "TriggerUpdateParameters"
                }
            },
            credentials: {
                serializedName: "properties.credentials",
                type: {
                    name: "Composite",
                    className: "Credentials"
                }
            },
            logTemplate: {
                serializedName: "properties.logTemplate",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PlatformUpdateParameters = {
    type: {
        name: "Composite",
        className: "PlatformUpdateParameters",
        modelProperties: {
            os: {
                serializedName: "os",
                type: {
                    name: "String"
                }
            },
            architecture: {
                serializedName: "architecture",
                type: {
                    name: "String"
                }
            },
            variant: {
                serializedName: "variant",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TaskStepUpdateParameters = {
    type: {
        name: "Composite",
        className: "TaskStepUpdateParameters",
        uberParent: "TaskStepUpdateParameters",
        polymorphicDiscriminator: {
            serializedName: "type",
            clientName: "type"
        },
        modelProperties: {
            type: {
                serializedName: "type",
                required: true,
                type: {
                    name: "String"
                }
            },
            contextPath: {
                serializedName: "contextPath",
                type: {
                    name: "String"
                }
            },
            contextAccessToken: {
                serializedName: "contextAccessToken",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TriggerUpdateParameters = {
    type: {
        name: "Composite",
        className: "TriggerUpdateParameters",
        modelProperties: {
            timerTriggers: {
                serializedName: "timerTriggers",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TimerTriggerUpdateParameters"
                        }
                    }
                }
            },
            sourceTriggers: {
                serializedName: "sourceTriggers",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SourceTriggerUpdateParameters"
                        }
                    }
                }
            },
            baseImageTrigger: {
                serializedName: "baseImageTrigger",
                type: {
                    name: "Composite",
                    className: "BaseImageTriggerUpdateParameters"
                }
            }
        }
    }
};
const TimerTriggerUpdateParameters = {
    type: {
        name: "Composite",
        className: "TimerTriggerUpdateParameters",
        modelProperties: {
            schedule: {
                serializedName: "schedule",
                type: {
                    name: "String"
                }
            },
            status: {
                serializedName: "status",
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SourceTriggerUpdateParameters = {
    type: {
        name: "Composite",
        className: "SourceTriggerUpdateParameters",
        modelProperties: {
            sourceRepository: {
                serializedName: "sourceRepository",
                type: {
                    name: "Composite",
                    className: "SourceUpdateParameters"
                }
            },
            sourceTriggerEvents: {
                serializedName: "sourceTriggerEvents",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            status: {
                serializedName: "status",
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SourceUpdateParameters = {
    type: {
        name: "Composite",
        className: "SourceUpdateParameters",
        modelProperties: {
            sourceControlType: {
                serializedName: "sourceControlType",
                type: {
                    name: "String"
                }
            },
            repositoryUrl: {
                serializedName: "repositoryUrl",
                type: {
                    name: "String"
                }
            },
            branch: {
                serializedName: "branch",
                type: {
                    name: "String"
                }
            },
            sourceControlAuthProperties: {
                serializedName: "sourceControlAuthProperties",
                type: {
                    name: "Composite",
                    className: "AuthInfoUpdateParameters"
                }
            }
        }
    }
};
const AuthInfoUpdateParameters = {
    type: {
        name: "Composite",
        className: "AuthInfoUpdateParameters",
        modelProperties: {
            tokenType: {
                serializedName: "tokenType",
                type: {
                    name: "String"
                }
            },
            token: {
                serializedName: "token",
                type: {
                    name: "String"
                }
            },
            refreshToken: {
                serializedName: "refreshToken",
                type: {
                    name: "String"
                }
            },
            scope: {
                serializedName: "scope",
                type: {
                    name: "String"
                }
            },
            expiresIn: {
                serializedName: "expiresIn",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const BaseImageTriggerUpdateParameters = {
    type: {
        name: "Composite",
        className: "BaseImageTriggerUpdateParameters",
        modelProperties: {
            baseImageTriggerType: {
                serializedName: "baseImageTriggerType",
                type: {
                    name: "String"
                }
            },
            updateTriggerEndpoint: {
                serializedName: "updateTriggerEndpoint",
                type: {
                    name: "String"
                }
            },
            updateTriggerPayloadType: {
                serializedName: "updateTriggerPayloadType",
                type: {
                    name: "String"
                }
            },
            status: {
                serializedName: "status",
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const StorageAccountProperties = {
    type: {
        name: "Composite",
        className: "StorageAccountProperties",
        modelProperties: {
            id: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PackageType = {
    type: {
        name: "Composite",
        className: "PackageType",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            endpoint: {
                serializedName: "endpoint",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RunFilter = {
    type: {
        name: "Composite",
        className: "RunFilter",
        modelProperties: {
            runId: {
                serializedName: "runId",
                type: {
                    name: "String"
                }
            },
            runType: {
                serializedName: "runType",
                type: {
                    name: "String"
                }
            },
            status: {
                serializedName: "status",
                type: {
                    name: "String"
                }
            },
            createTime: {
                serializedName: "createTime",
                type: {
                    name: "DateTime"
                }
            },
            finishTime: {
                serializedName: "finishTime",
                type: {
                    name: "DateTime"
                }
            },
            outputImageManifests: {
                serializedName: "outputImageManifests",
                type: {
                    name: "String"
                }
            },
            isArchiveEnabled: {
                serializedName: "isArchiveEnabled",
                type: {
                    name: "Boolean"
                }
            },
            taskName: {
                serializedName: "taskName",
                type: {
                    name: "String"
                }
            },
            agentPoolName: {
                serializedName: "agentPoolName",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Argument = {
    type: {
        name: "Composite",
        className: "Argument",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "String"
                }
            },
            isSecret: {
                defaultValue: false,
                serializedName: "isSecret",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const SetValue = {
    type: {
        name: "Composite",
        className: "SetValue",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "String"
                }
            },
            isSecret: {
                defaultValue: false,
                serializedName: "isSecret",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const OverrideTaskStepProperties = {
    type: {
        name: "Composite",
        className: "OverrideTaskStepProperties",
        modelProperties: {
            contextPath: {
                serializedName: "contextPath",
                type: {
                    name: "String"
                }
            },
            file: {
                serializedName: "file",
                type: {
                    name: "String"
                }
            },
            arguments: {
                serializedName: "arguments",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Argument"
                        }
                    }
                }
            },
            target: {
                serializedName: "target",
                type: {
                    name: "String"
                }
            },
            values: {
                serializedName: "values",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SetValue"
                        }
                    }
                }
            },
            updateTriggerToken: {
                serializedName: "updateTriggerToken",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PrivateEndpointConnection = {
    type: {
        name: "Composite",
        className: "PrivateEndpointConnection",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { privateEndpoint: {
                serializedName: "properties.privateEndpoint",
                type: {
                    name: "Composite",
                    className: "PrivateEndpoint"
                }
            }, privateLinkServiceConnectionState: {
                serializedName: "properties.privateLinkServiceConnectionState",
                type: {
                    name: "Composite",
                    className: "PrivateLinkServiceConnectionState"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const Run = {
    type: {
        name: "Composite",
        className: "Run",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { runId: {
                serializedName: "properties.runId",
                type: {
                    name: "String"
                }
            }, status: {
                serializedName: "properties.status",
                type: {
                    name: "String"
                }
            }, lastUpdatedTime: {
                serializedName: "properties.lastUpdatedTime",
                type: {
                    name: "DateTime"
                }
            }, runType: {
                serializedName: "properties.runType",
                type: {
                    name: "String"
                }
            }, agentPoolName: {
                serializedName: "properties.agentPoolName",
                type: {
                    name: "String"
                }
            }, createTime: {
                serializedName: "properties.createTime",
                type: {
                    name: "DateTime"
                }
            }, startTime: {
                serializedName: "properties.startTime",
                type: {
                    name: "DateTime"
                }
            }, finishTime: {
                serializedName: "properties.finishTime",
                type: {
                    name: "DateTime"
                }
            }, outputImages: {
                serializedName: "properties.outputImages",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ImageDescriptor"
                        }
                    }
                }
            }, task: {
                serializedName: "properties.task",
                type: {
                    name: "String"
                }
            }, imageUpdateTrigger: {
                serializedName: "properties.imageUpdateTrigger",
                type: {
                    name: "Composite",
                    className: "ImageUpdateTrigger"
                }
            }, sourceTrigger: {
                serializedName: "properties.sourceTrigger",
                type: {
                    name: "Composite",
                    className: "SourceTriggerDescriptor"
                }
            }, timerTrigger: {
                serializedName: "properties.timerTrigger",
                type: {
                    name: "Composite",
                    className: "TimerTriggerDescriptor"
                }
            }, platform: {
                serializedName: "properties.platform",
                type: {
                    name: "Composite",
                    className: "PlatformProperties"
                }
            }, agentConfiguration: {
                serializedName: "properties.agentConfiguration",
                type: {
                    name: "Composite",
                    className: "AgentProperties"
                }
            }, sourceRegistryAuth: {
                serializedName: "properties.sourceRegistryAuth",
                type: {
                    name: "String"
                }
            }, customRegistries: {
                serializedName: "properties.customRegistries",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, runErrorMessage: {
                serializedName: "properties.runErrorMessage",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, updateTriggerToken: {
                serializedName: "properties.updateTriggerToken",
                type: {
                    name: "String"
                }
            }, logArtifact: {
                serializedName: "properties.logArtifact",
                type: {
                    name: "Composite",
                    className: "ImageDescriptor"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                type: {
                    name: "String"
                }
            }, isArchiveEnabled: {
                defaultValue: false,
                serializedName: "properties.isArchiveEnabled",
                type: {
                    name: "Boolean"
                }
            } })
    }
};
const TaskRun = {
    type: {
        name: "Composite",
        className: "TaskRun",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { identity: {
                serializedName: "identity",
                type: {
                    name: "Composite",
                    className: "IdentityProperties"
                }
            }, location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, runRequest: {
                serializedName: "properties.runRequest",
                type: {
                    name: "Composite",
                    className: "RunRequest"
                }
            }, runResult: {
                serializedName: "properties.runResult",
                type: {
                    name: "Composite",
                    className: "Run"
                }
            }, forceUpdateTag: {
                serializedName: "properties.forceUpdateTag",
                type: {
                    name: "String"
                }
            } })
    }
};
const Registry = {
    type: {
        name: "Composite",
        className: "Registry",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { sku: {
                serializedName: "sku",
                type: {
                    name: "Composite",
                    className: "Sku"
                }
            }, identity: {
                serializedName: "identity",
                type: {
                    name: "Composite",
                    className: "IdentityProperties"
                }
            }, loginServer: {
                serializedName: "properties.loginServer",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, creationDate: {
                serializedName: "properties.creationDate",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, status: {
                serializedName: "properties.status",
                type: {
                    name: "Composite",
                    className: "Status"
                }
            }, adminUserEnabled: {
                defaultValue: false,
                serializedName: "properties.adminUserEnabled",
                type: {
                    name: "Boolean"
                }
            }, networkRuleSet: {
                serializedName: "properties.networkRuleSet",
                type: {
                    name: "Composite",
                    className: "NetworkRuleSet"
                }
            }, policies: {
                serializedName: "properties.policies",
                type: {
                    name: "Composite",
                    className: "Policies"
                }
            }, encryption: {
                serializedName: "properties.encryption",
                type: {
                    name: "Composite",
                    className: "EncryptionProperty"
                }
            }, dataEndpointEnabled: {
                serializedName: "properties.dataEndpointEnabled",
                type: {
                    name: "Boolean"
                }
            }, dataEndpointHostNames: {
                serializedName: "properties.dataEndpointHostNames",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, privateEndpointConnections: {
                serializedName: "properties.privateEndpointConnections",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PrivateEndpointConnection"
                        }
                    }
                }
            }, publicNetworkAccess: {
                serializedName: "properties.publicNetworkAccess",
                type: {
                    name: "String"
                }
            }, networkRuleBypassOptions: {
                serializedName: "properties.networkRuleBypassOptions",
                type: {
                    name: "String"
                }
            }, zoneRedundancy: {
                serializedName: "properties.zoneRedundancy",
                type: {
                    name: "String"
                }
            } })
    }
};
const Replication = {
    type: {
        name: "Composite",
        className: "Replication",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, status: {
                serializedName: "properties.status",
                type: {
                    name: "Composite",
                    className: "Status"
                }
            }, regionEndpointEnabled: {
                defaultValue: true,
                serializedName: "properties.regionEndpointEnabled",
                type: {
                    name: "Boolean"
                }
            }, zoneRedundancy: {
                serializedName: "properties.zoneRedundancy",
                type: {
                    name: "String"
                }
            } })
    }
};
const Webhook = {
    type: {
        name: "Composite",
        className: "Webhook",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { status: {
                serializedName: "properties.status",
                type: {
                    name: "String"
                }
            }, scope: {
                serializedName: "properties.scope",
                type: {
                    name: "String"
                }
            }, actions: {
                serializedName: "properties.actions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const AgentPool = {
    type: {
        name: "Composite",
        className: "AgentPool",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { count: {
                serializedName: "properties.count",
                type: {
                    name: "Number"
                }
            }, tier: {
                serializedName: "properties.tier",
                type: {
                    name: "String"
                }
            }, os: {
                serializedName: "properties.os",
                type: {
                    name: "String"
                }
            }, virtualNetworkSubnetResourceId: {
                serializedName: "properties.virtualNetworkSubnetResourceId",
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const Task = {
    type: {
        name: "Composite",
        className: "Task",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { identity: {
                serializedName: "identity",
                type: {
                    name: "Composite",
                    className: "IdentityProperties"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, creationDate: {
                serializedName: "properties.creationDate",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, status: {
                serializedName: "properties.status",
                type: {
                    name: "String"
                }
            }, platform: {
                serializedName: "properties.platform",
                type: {
                    name: "Composite",
                    className: "PlatformProperties"
                }
            }, agentConfiguration: {
                serializedName: "properties.agentConfiguration",
                type: {
                    name: "Composite",
                    className: "AgentProperties"
                }
            }, agentPoolName: {
                serializedName: "properties.agentPoolName",
                type: {
                    name: "String"
                }
            }, timeout: {
                defaultValue: 3600,
                constraints: {
                    InclusiveMaximum: 28800,
                    InclusiveMinimum: 300
                },
                serializedName: "properties.timeout",
                type: {
                    name: "Number"
                }
            }, step: {
                serializedName: "properties.step",
                type: {
                    name: "Composite",
                    className: "TaskStepProperties"
                }
            }, trigger: {
                serializedName: "properties.trigger",
                type: {
                    name: "Composite",
                    className: "TriggerProperties"
                }
            }, credentials: {
                serializedName: "properties.credentials",
                type: {
                    name: "Composite",
                    className: "Credentials"
                }
            }, logTemplate: {
                serializedName: "properties.logTemplate",
                type: {
                    name: "String"
                }
            }, isSystemTask: {
                defaultValue: false,
                serializedName: "properties.isSystemTask",
                type: {
                    name: "Boolean"
                }
            } })
    }
};
const Event = {
    type: {
        name: "Composite",
        className: "Event",
        modelProperties: Object.assign(Object.assign({}, EventInfo.type.modelProperties), { eventRequestMessage: {
                serializedName: "eventRequestMessage",
                type: {
                    name: "Composite",
                    className: "EventRequestMessage"
                }
            }, eventResponseMessage: {
                serializedName: "eventResponseMessage",
                type: {
                    name: "Composite",
                    className: "EventResponseMessage"
                }
            } })
    }
};
const DockerBuildRequest = {
    serializedName: "DockerBuildRequest",
    type: {
        name: "Composite",
        className: "DockerBuildRequest",
        uberParent: "RunRequest",
        polymorphicDiscriminator: RunRequest.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, RunRequest.type.modelProperties), { imageNames: {
                serializedName: "imageNames",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, isPushEnabled: {
                defaultValue: true,
                serializedName: "isPushEnabled",
                type: {
                    name: "Boolean"
                }
            }, noCache: {
                defaultValue: false,
                serializedName: "noCache",
                type: {
                    name: "Boolean"
                }
            }, dockerFilePath: {
                serializedName: "dockerFilePath",
                required: true,
                type: {
                    name: "String"
                }
            }, target: {
                serializedName: "target",
                type: {
                    name: "String"
                }
            }, arguments: {
                serializedName: "arguments",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Argument"
                        }
                    }
                }
            }, timeout: {
                defaultValue: 3600,
                constraints: {
                    InclusiveMaximum: 28800,
                    InclusiveMinimum: 300
                },
                serializedName: "timeout",
                type: {
                    name: "Number"
                }
            }, platform: {
                serializedName: "platform",
                type: {
                    name: "Composite",
                    className: "PlatformProperties"
                }
            }, agentConfiguration: {
                serializedName: "agentConfiguration",
                type: {
                    name: "Composite",
                    className: "AgentProperties"
                }
            }, sourceLocation: {
                serializedName: "sourceLocation",
                type: {
                    name: "String"
                }
            }, credentials: {
                serializedName: "credentials",
                type: {
                    name: "Composite",
                    className: "Credentials"
                }
            } })
    }
};
const FileTaskRunRequest = {
    serializedName: "FileTaskRunRequest",
    type: {
        name: "Composite",
        className: "FileTaskRunRequest",
        uberParent: "RunRequest",
        polymorphicDiscriminator: RunRequest.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, RunRequest.type.modelProperties), { taskFilePath: {
                serializedName: "taskFilePath",
                required: true,
                type: {
                    name: "String"
                }
            }, valuesFilePath: {
                serializedName: "valuesFilePath",
                type: {
                    name: "String"
                }
            }, values: {
                serializedName: "values",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SetValue"
                        }
                    }
                }
            }, timeout: {
                defaultValue: 3600,
                constraints: {
                    InclusiveMaximum: 28800,
                    InclusiveMinimum: 300
                },
                serializedName: "timeout",
                type: {
                    name: "Number"
                }
            }, platform: {
                serializedName: "platform",
                type: {
                    name: "Composite",
                    className: "PlatformProperties"
                }
            }, agentConfiguration: {
                serializedName: "agentConfiguration",
                type: {
                    name: "Composite",
                    className: "AgentProperties"
                }
            }, sourceLocation: {
                serializedName: "sourceLocation",
                type: {
                    name: "String"
                }
            }, credentials: {
                serializedName: "credentials",
                type: {
                    name: "Composite",
                    className: "Credentials"
                }
            } })
    }
};
const TaskRunRequest = {
    serializedName: "TaskRunRequest",
    type: {
        name: "Composite",
        className: "TaskRunRequest",
        uberParent: "RunRequest",
        polymorphicDiscriminator: RunRequest.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, RunRequest.type.modelProperties), { taskId: {
                serializedName: "taskId",
                required: true,
                type: {
                    name: "String"
                }
            }, overrideTaskStepProperties: {
                serializedName: "overrideTaskStepProperties",
                type: {
                    name: "Composite",
                    className: "OverrideTaskStepProperties"
                }
            } })
    }
};
const EncodedTaskRunRequest = {
    serializedName: "EncodedTaskRunRequest",
    type: {
        name: "Composite",
        className: "EncodedTaskRunRequest",
        uberParent: "RunRequest",
        polymorphicDiscriminator: RunRequest.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, RunRequest.type.modelProperties), { encodedTaskContent: {
                serializedName: "encodedTaskContent",
                required: true,
                type: {
                    name: "String"
                }
            }, encodedValuesContent: {
                serializedName: "encodedValuesContent",
                type: {
                    name: "String"
                }
            }, values: {
                serializedName: "values",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SetValue"
                        }
                    }
                }
            }, timeout: {
                defaultValue: 3600,
                constraints: {
                    InclusiveMaximum: 28800,
                    InclusiveMinimum: 300
                },
                serializedName: "timeout",
                type: {
                    name: "Number"
                }
            }, platform: {
                serializedName: "platform",
                type: {
                    name: "Composite",
                    className: "PlatformProperties"
                }
            }, agentConfiguration: {
                serializedName: "agentConfiguration",
                type: {
                    name: "Composite",
                    className: "AgentProperties"
                }
            }, sourceLocation: {
                serializedName: "sourceLocation",
                type: {
                    name: "String"
                }
            }, credentials: {
                serializedName: "credentials",
                type: {
                    name: "Composite",
                    className: "Credentials"
                }
            } })
    }
};
const DockerBuildStep = {
    serializedName: "Docker",
    type: {
        name: "Composite",
        className: "DockerBuildStep",
        uberParent: "TaskStepProperties",
        polymorphicDiscriminator: TaskStepProperties.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, TaskStepProperties.type.modelProperties), { imageNames: {
                serializedName: "imageNames",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, isPushEnabled: {
                defaultValue: true,
                serializedName: "isPushEnabled",
                type: {
                    name: "Boolean"
                }
            }, noCache: {
                defaultValue: false,
                serializedName: "noCache",
                type: {
                    name: "Boolean"
                }
            }, dockerFilePath: {
                serializedName: "dockerFilePath",
                required: true,
                type: {
                    name: "String"
                }
            }, target: {
                serializedName: "target",
                type: {
                    name: "String"
                }
            }, arguments: {
                serializedName: "arguments",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Argument"
                        }
                    }
                }
            } })
    }
};
const FileTaskStep = {
    serializedName: "FileTask",
    type: {
        name: "Composite",
        className: "FileTaskStep",
        uberParent: "TaskStepProperties",
        polymorphicDiscriminator: TaskStepProperties.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, TaskStepProperties.type.modelProperties), { taskFilePath: {
                serializedName: "taskFilePath",
                required: true,
                type: {
                    name: "String"
                }
            }, valuesFilePath: {
                serializedName: "valuesFilePath",
                type: {
                    name: "String"
                }
            }, values: {
                serializedName: "values",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SetValue"
                        }
                    }
                }
            } })
    }
};
const EncodedTaskStep = {
    serializedName: "EncodedTask",
    type: {
        name: "Composite",
        className: "EncodedTaskStep",
        uberParent: "TaskStepProperties",
        polymorphicDiscriminator: TaskStepProperties.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, TaskStepProperties.type.modelProperties), { encodedTaskContent: {
                serializedName: "encodedTaskContent",
                required: true,
                type: {
                    name: "String"
                }
            }, encodedValuesContent: {
                serializedName: "encodedValuesContent",
                type: {
                    name: "String"
                }
            }, values: {
                serializedName: "values",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SetValue"
                        }
                    }
                }
            } })
    }
};
const DockerBuildStepUpdateParameters = {
    serializedName: "Docker",
    type: {
        name: "Composite",
        className: "DockerBuildStepUpdateParameters",
        uberParent: "TaskStepUpdateParameters",
        polymorphicDiscriminator: TaskStepUpdateParameters.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, TaskStepUpdateParameters.type.modelProperties), { imageNames: {
                serializedName: "imageNames",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, isPushEnabled: {
                serializedName: "isPushEnabled",
                type: {
                    name: "Boolean"
                }
            }, noCache: {
                serializedName: "noCache",
                type: {
                    name: "Boolean"
                }
            }, dockerFilePath: {
                serializedName: "dockerFilePath",
                type: {
                    name: "String"
                }
            }, arguments: {
                serializedName: "arguments",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Argument"
                        }
                    }
                }
            }, target: {
                serializedName: "target",
                type: {
                    name: "String"
                }
            } })
    }
};
const FileTaskStepUpdateParameters = {
    serializedName: "FileTask",
    type: {
        name: "Composite",
        className: "FileTaskStepUpdateParameters",
        uberParent: "TaskStepUpdateParameters",
        polymorphicDiscriminator: TaskStepUpdateParameters.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, TaskStepUpdateParameters.type.modelProperties), { taskFilePath: {
                serializedName: "taskFilePath",
                type: {
                    name: "String"
                }
            }, valuesFilePath: {
                serializedName: "valuesFilePath",
                type: {
                    name: "String"
                }
            }, values: {
                serializedName: "values",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SetValue"
                        }
                    }
                }
            } })
    }
};
const EncodedTaskStepUpdateParameters = {
    serializedName: "EncodedTask",
    type: {
        name: "Composite",
        className: "EncodedTaskStepUpdateParameters",
        uberParent: "TaskStepUpdateParameters",
        polymorphicDiscriminator: TaskStepUpdateParameters.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, TaskStepUpdateParameters.type.modelProperties), { encodedTaskContent: {
                serializedName: "encodedTaskContent",
                type: {
                    name: "String"
                }
            }, encodedValuesContent: {
                serializedName: "encodedValuesContent",
                type: {
                    name: "String"
                }
            }, values: {
                serializedName: "values",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SetValue"
                        }
                    }
                }
            } })
    }
};
let discriminators = {
    RunRequest: RunRequest,
    TaskStepProperties: TaskStepProperties,
    TaskStepUpdateParameters: TaskStepUpdateParameters,
    "RunRequest.DockerBuildRequest": DockerBuildRequest,
    "RunRequest.FileTaskRunRequest": FileTaskRunRequest,
    "RunRequest.TaskRunRequest": TaskRunRequest,
    "RunRequest.EncodedTaskRunRequest": EncodedTaskRunRequest,
    "TaskStepProperties.Docker": DockerBuildStep,
    "TaskStepProperties.FileTask": FileTaskStep,
    "TaskStepProperties.EncodedTask": EncodedTaskStep,
    "TaskStepUpdateParameters.Docker": DockerBuildStepUpdateParameters,
    "TaskStepUpdateParameters.FileTask": FileTaskStepUpdateParameters,
    "TaskStepUpdateParameters.EncodedTask": EncodedTaskStepUpdateParameters
};

var Mappers = /*#__PURE__*/Object.freeze({
    __proto__: null,
    ImportImageParameters: ImportImageParameters,
    ImportSource: ImportSource,
    ImportSourceCredentials: ImportSourceCredentials,
    OperationListResult: OperationListResult,
    OperationDefinition: OperationDefinition,
    OperationDisplayDefinition: OperationDisplayDefinition,
    OperationServiceSpecificationDefinition: OperationServiceSpecificationDefinition,
    OperationMetricSpecificationDefinition: OperationMetricSpecificationDefinition,
    OperationLogSpecificationDefinition: OperationLogSpecificationDefinition,
    RegistryNameCheckRequest: RegistryNameCheckRequest,
    RegistryNameStatus: RegistryNameStatus,
    PrivateEndpointConnectionListResult: PrivateEndpointConnectionListResult,
    PrivateEndpoint: PrivateEndpoint,
    PrivateLinkServiceConnectionState: PrivateLinkServiceConnectionState,
    ProxyResource: ProxyResource,
    SystemData: SystemData,
    RegistryListResult: RegistryListResult,
    Sku: Sku,
    IdentityProperties: IdentityProperties,
    UserIdentityProperties: UserIdentityProperties,
    Status: Status,
    NetworkRuleSet: NetworkRuleSet,
    IPRule: IPRule,
    Policies: Policies,
    QuarantinePolicy: QuarantinePolicy,
    TrustPolicy: TrustPolicy,
    RetentionPolicy: RetentionPolicy,
    ExportPolicy: ExportPolicy,
    EncryptionProperty: EncryptionProperty,
    KeyVaultProperties: KeyVaultProperties,
    Resource: Resource,
    RegistryUpdateParameters: RegistryUpdateParameters,
    RegistryUsageListResult: RegistryUsageListResult,
    RegistryUsage: RegistryUsage,
    PrivateLinkResourceListResult: PrivateLinkResourceListResult,
    PrivateLinkResource: PrivateLinkResource,
    ErrorResponse: ErrorResponse,
    ErrorResponseBody: ErrorResponseBody,
    InnerErrorDescription: InnerErrorDescription,
    RegistryListCredentialsResult: RegistryListCredentialsResult,
    RegistryPassword: RegistryPassword,
    RegenerateCredentialParameters: RegenerateCredentialParameters,
    ReplicationListResult: ReplicationListResult,
    ReplicationUpdateParameters: ReplicationUpdateParameters,
    WebhookListResult: WebhookListResult,
    WebhookCreateParameters: WebhookCreateParameters,
    WebhookUpdateParameters: WebhookUpdateParameters,
    EventInfo: EventInfo,
    EventListResult: EventListResult,
    EventRequestMessage: EventRequestMessage,
    EventContent: EventContent,
    Target: Target,
    Request: Request,
    Actor: Actor,
    Source: Source,
    EventResponseMessage: EventResponseMessage,
    CallbackConfig: CallbackConfig,
    AgentPoolUpdateParameters: AgentPoolUpdateParameters,
    AgentPoolListResult: AgentPoolListResult,
    AgentPoolQueueStatus: AgentPoolQueueStatus,
    RunRequest: RunRequest,
    ImageDescriptor: ImageDescriptor,
    ImageUpdateTrigger: ImageUpdateTrigger,
    SourceTriggerDescriptor: SourceTriggerDescriptor,
    TimerTriggerDescriptor: TimerTriggerDescriptor,
    PlatformProperties: PlatformProperties,
    AgentProperties: AgentProperties,
    SourceUploadDefinition: SourceUploadDefinition,
    RunListResult: RunListResult,
    RunUpdateParameters: RunUpdateParameters,
    RunGetLogResult: RunGetLogResult,
    TaskRunUpdateParameters: TaskRunUpdateParameters,
    TaskRunListResult: TaskRunListResult,
    TaskListResult: TaskListResult,
    TaskStepProperties: TaskStepProperties,
    BaseImageDependency: BaseImageDependency,
    TriggerProperties: TriggerProperties,
    TimerTrigger: TimerTrigger,
    SourceTrigger: SourceTrigger,
    SourceProperties: SourceProperties,
    AuthInfo: AuthInfo,
    BaseImageTrigger: BaseImageTrigger,
    Credentials: Credentials,
    SourceRegistryCredentials: SourceRegistryCredentials,
    CustomRegistryCredentials: CustomRegistryCredentials,
    SecretObject: SecretObject,
    TaskUpdateParameters: TaskUpdateParameters,
    PlatformUpdateParameters: PlatformUpdateParameters,
    TaskStepUpdateParameters: TaskStepUpdateParameters,
    TriggerUpdateParameters: TriggerUpdateParameters,
    TimerTriggerUpdateParameters: TimerTriggerUpdateParameters,
    SourceTriggerUpdateParameters: SourceTriggerUpdateParameters,
    SourceUpdateParameters: SourceUpdateParameters,
    AuthInfoUpdateParameters: AuthInfoUpdateParameters,
    BaseImageTriggerUpdateParameters: BaseImageTriggerUpdateParameters,
    StorageAccountProperties: StorageAccountProperties,
    PackageType: PackageType,
    RunFilter: RunFilter,
    Argument: Argument,
    SetValue: SetValue,
    OverrideTaskStepProperties: OverrideTaskStepProperties,
    PrivateEndpointConnection: PrivateEndpointConnection,
    Run: Run,
    TaskRun: TaskRun,
    Registry: Registry,
    Replication: Replication,
    Webhook: Webhook,
    AgentPool: AgentPool,
    Task: Task,
    Event: Event,
    DockerBuildRequest: DockerBuildRequest,
    FileTaskRunRequest: FileTaskRunRequest,
    TaskRunRequest: TaskRunRequest,
    EncodedTaskRunRequest: EncodedTaskRunRequest,
    DockerBuildStep: DockerBuildStep,
    FileTaskStep: FileTaskStep,
    EncodedTaskStep: EncodedTaskStep,
    DockerBuildStepUpdateParameters: DockerBuildStepUpdateParameters,
    FileTaskStepUpdateParameters: FileTaskStepUpdateParameters,
    EncodedTaskStepUpdateParameters: EncodedTaskStepUpdateParameters,
    discriminators: discriminators
});

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const contentType = {
    parameterPath: ["options", "contentType"],
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Content-Type",
        type: {
            name: "String"
        }
    }
};
const parameters = {
    parameterPath: "parameters",
    mapper: ImportImageParameters
};
const $host = {
    parameterPath: "$host",
    mapper: {
        serializedName: "$host",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const apiVersion = {
    parameterPath: "apiVersion",
    mapper: {
        defaultValue: "2021-09-01",
        isConstant: true,
        serializedName: "api-version",
        type: {
            name: "String"
        }
    }
};
const subscriptionId = {
    parameterPath: "subscriptionId",
    mapper: {
        serializedName: "subscriptionId",
        required: true,
        type: {
            name: "String"
        }
    }
};
const resourceGroupName = {
    parameterPath: "resourceGroupName",
    mapper: {
        constraints: {
            MinLength: 1
        },
        serializedName: "resourceGroupName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const registryName = {
    parameterPath: "registryName",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[a-zA-Z0-9]*$"),
            MaxLength: 50,
            MinLength: 5
        },
        serializedName: "registryName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const registryNameCheckRequest = {
    parameterPath: "registryNameCheckRequest",
    mapper: RegistryNameCheckRequest
};
const accept = {
    parameterPath: "accept",
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Accept",
        type: {
            name: "String"
        }
    }
};
const registry = {
    parameterPath: "registry",
    mapper: Registry
};
const registryUpdateParameters = {
    parameterPath: "registryUpdateParameters",
    mapper: RegistryUpdateParameters
};
const groupName = {
    parameterPath: "groupName",
    mapper: {
        serializedName: "groupName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const regenerateCredentialParameters = {
    parameterPath: "regenerateCredentialParameters",
    mapper: RegenerateCredentialParameters
};
const runRequest = {
    parameterPath: "runRequest",
    mapper: RunRequest
};
const apiVersion1 = {
    parameterPath: "apiVersion",
    mapper: {
        defaultValue: "2019-06-01-preview",
        isConstant: true,
        serializedName: "api-version",
        type: {
            name: "String"
        }
    }
};
const nextLink = {
    parameterPath: "nextLink",
    mapper: {
        serializedName: "nextLink",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const privateEndpointConnectionName = {
    parameterPath: "privateEndpointConnectionName",
    mapper: {
        serializedName: "privateEndpointConnectionName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const privateEndpointConnection = {
    parameterPath: "privateEndpointConnection",
    mapper: PrivateEndpointConnection
};
const replicationName = {
    parameterPath: "replicationName",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[a-zA-Z0-9]*$"),
            MaxLength: 50,
            MinLength: 5
        },
        serializedName: "replicationName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const replication = {
    parameterPath: "replication",
    mapper: Replication
};
const replicationUpdateParameters = {
    parameterPath: "replicationUpdateParameters",
    mapper: ReplicationUpdateParameters
};
const webhookName = {
    parameterPath: "webhookName",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[a-zA-Z0-9]*$"),
            MaxLength: 50,
            MinLength: 5
        },
        serializedName: "webhookName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const webhookCreateParameters = {
    parameterPath: "webhookCreateParameters",
    mapper: WebhookCreateParameters
};
const webhookUpdateParameters = {
    parameterPath: "webhookUpdateParameters",
    mapper: WebhookUpdateParameters
};
const agentPoolName = {
    parameterPath: "agentPoolName",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[a-zA-Z0-9-]*$"),
            MaxLength: 20,
            MinLength: 3
        },
        serializedName: "agentPoolName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const agentPool = {
    parameterPath: "agentPool",
    mapper: AgentPool
};
const updateParameters = {
    parameterPath: "updateParameters",
    mapper: AgentPoolUpdateParameters
};
const filter = {
    parameterPath: ["options", "filter"],
    mapper: {
        serializedName: "$filter",
        type: {
            name: "String"
        }
    }
};
const top = {
    parameterPath: ["options", "top"],
    mapper: {
        serializedName: "$top",
        type: {
            name: "Number"
        }
    }
};
const runId = {
    parameterPath: "runId",
    mapper: {
        serializedName: "runId",
        required: true,
        type: {
            name: "String"
        }
    }
};
const runUpdateParameters = {
    parameterPath: "runUpdateParameters",
    mapper: RunUpdateParameters
};
const taskRunName = {
    parameterPath: "taskRunName",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[a-zA-Z0-9-]*$"),
            MaxLength: 50,
            MinLength: 5
        },
        serializedName: "taskRunName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const taskRun = {
    parameterPath: "taskRun",
    mapper: TaskRun
};
const updateParameters1 = {
    parameterPath: "updateParameters",
    mapper: TaskRunUpdateParameters
};
const taskName = {
    parameterPath: "taskName",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[a-zA-Z0-9-_]*$"),
            MaxLength: 50,
            MinLength: 5
        },
        serializedName: "taskName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const taskCreateParameters = {
    parameterPath: "taskCreateParameters",
    mapper: Task
};
const taskUpdateParameters = {
    parameterPath: "taskUpdateParameters",
    mapper: TaskUpdateParameters
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
class LroImpl {
    constructor(sendOperationFn, args, spec, requestPath = spec.path, requestMethod = spec.httpMethod) {
        this.sendOperationFn = sendOperationFn;
        this.args = args;
        this.spec = spec;
        this.requestPath = requestPath;
        this.requestMethod = requestMethod;
    }
    sendInitialRequest() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return this.sendOperationFn(this.args, this.spec);
        });
    }
    sendPollRequest(path) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const _a = this.spec, restSpec = tslib.__rest(_a, ["requestBody"]);
            return this.sendOperationFn(this.args, Object.assign(Object.assign({}, restSpec), { path, httpMethod: "GET" }));
        });
    }
}

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Registries operations. */
class RegistriesImpl {
    /**
     * Initialize a new instance of the class Registries class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all the container registries under the specified subscription.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(options);
            }
        };
    }
    listPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all the container registries under the specified resource group.
     * @param resourceGroupName The name of the resource group to which the container registry belongs.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByResourceGroupPagingPage(resourceGroupName, options);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Lists the private link resources for a container registry.
     * @param resourceGroupName The name of the resource group to which the container registry belongs.
     * @param registryName The name of the container registry.
     * @param options The options parameters.
     */
    listPrivateLinkResources(resourceGroupName, registryName, options) {
        const iter = this.listPrivateLinkResourcesPagingAll(resourceGroupName, registryName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPrivateLinkResourcesPagingPage(resourceGroupName, registryName, options);
            }
        };
    }
    listPrivateLinkResourcesPagingPage(resourceGroupName, registryName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPrivateLinkResourcesPagingPage_1() {
            let result = yield tslib.__await(this._listPrivateLinkResources(resourceGroupName, registryName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listPrivateLinkResourcesNext(resourceGroupName, registryName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPrivateLinkResourcesPagingAll(resourceGroupName, registryName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPrivateLinkResourcesPagingAll_1() {
            var e_3, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPrivateLinkResourcesPagingPage(resourceGroupName, registryName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_3) throw e_3.error; }
            }
        });
    }
    /**
     * Copies an image to this container registry from the specified container registry.
     * @param resourceGroupName The name of the resource group to which the container registry belongs.
     * @param registryName The name of the container registry.
     * @param parameters The parameters specifying the image to copy and the source container registry.
     * @param options The options parameters.
     */
    beginImportImage(resourceGroupName, registryName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, registryName, parameters, options }, importImageOperationSpec);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Copies an image to this container registry from the specified container registry.
     * @param resourceGroupName The name of the resource group to which the container registry belongs.
     * @param registryName The name of the container registry.
     * @param parameters The parameters specifying the image to copy and the source container registry.
     * @param options The options parameters.
     */
    beginImportImageAndWait(resourceGroupName, registryName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginImportImage(resourceGroupName, registryName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Checks whether the container registry name is available for use. The name must contain only
     * alphanumeric characters, be globally unique, and between 5 and 50 characters in length.
     * @param registryNameCheckRequest The object containing information for the availability request.
     * @param options The options parameters.
     */
    checkNameAvailability(registryNameCheckRequest, options) {
        return this.client.sendOperationRequest({ registryNameCheckRequest, options }, checkNameAvailabilityOperationSpec);
    }
    /**
     * Lists all the container registries under the specified subscription.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec);
    }
    /**
     * Lists all the container registries under the specified resource group.
     * @param resourceGroupName The name of the resource group to which the container registry belongs.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec);
    }
    /**
     * Gets the properties of the specified container registry.
     * @param resourceGroupName The name of the resource group to which the container registry belongs.
     * @param registryName The name of the container registry.
     * @param options The options parameters.
     */
    get(resourceGroupName, registryName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, registryName, options }, getOperationSpec);
    }
    /**
     * Creates a container registry with the specified parameters.
     * @param resourceGroupName The name of the resource group to which the container registry belongs.
     * @param registryName The name of the container registry.
     * @param registry The parameters for creating a container registry.
     * @param options The options parameters.
     */
    beginCreate(resourceGroupName, registryName, registry, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, registryName, registry, options }, createOperationSpec);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Creates a container registry with the specified parameters.
     * @param resourceGroupName The name of the resource group to which the container registry belongs.
     * @param registryName The name of the container registry.
     * @param registry The parameters for creating a container registry.
     * @param options The options parameters.
     */
    beginCreateAndWait(resourceGroupName, registryName, registry, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreate(resourceGroupName, registryName, registry, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes a container registry.
     * @param resourceGroupName The name of the resource group to which the container registry belongs.
     * @param registryName The name of the container registry.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, registryName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, registryName, options }, deleteOperationSpec);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Deletes a container registry.
     * @param resourceGroupName The name of the resource group to which the container registry belongs.
     * @param registryName The name of the container registry.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, registryName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, registryName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates a container registry with the specified parameters.
     * @param resourceGroupName The name of the resource group to which the container registry belongs.
     * @param registryName The name of the container registry.
     * @param registryUpdateParameters The parameters for updating a container registry.
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, registryName, registryUpdateParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, registryName, registryUpdateParameters, options }, updateOperationSpec);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Updates a container registry with the specified parameters.
     * @param resourceGroupName The name of the resource group to which the container registry belongs.
     * @param registryName The name of the container registry.
     * @param registryUpdateParameters The parameters for updating a container registry.
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, registryName, registryUpdateParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, registryName, registryUpdateParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the quota usages for the specified container registry.
     * @param resourceGroupName The name of the resource group to which the container registry belongs.
     * @param registryName The name of the container registry.
     * @param options The options parameters.
     */
    listUsages(resourceGroupName, registryName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, registryName, options }, listUsagesOperationSpec);
    }
    /**
     * Lists the private link resources for a container registry.
     * @param resourceGroupName The name of the resource group to which the container registry belongs.
     * @param registryName The name of the container registry.
     * @param options The options parameters.
     */
    _listPrivateLinkResources(resourceGroupName, registryName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, registryName, options }, listPrivateLinkResourcesOperationSpec);
    }
    /**
     * Gets a private link resource by a specified group name for a container registry.
     * @param resourceGroupName The name of the resource group to which the container registry belongs.
     * @param registryName The name of the container registry.
     * @param groupName The name of the private link resource.
     * @param options The options parameters.
     */
    getPrivateLinkResource(resourceGroupName, registryName, groupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, registryName, groupName, options }, getPrivateLinkResourceOperationSpec);
    }
    /**
     * Lists the login credentials for the specified container registry.
     * @param resourceGroupName The name of the resource group to which the container registry belongs.
     * @param registryName The name of the container registry.
     * @param options The options parameters.
     */
    listCredentials(resourceGroupName, registryName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, registryName, options }, listCredentialsOperationSpec);
    }
    /**
     * Regenerates one of the login credentials for the specified container registry.
     * @param resourceGroupName The name of the resource group to which the container registry belongs.
     * @param registryName The name of the container registry.
     * @param regenerateCredentialParameters Specifies name of the password which should be regenerated --
     *                                       password or password2.
     * @param options The options parameters.
     */
    regenerateCredential(resourceGroupName, registryName, regenerateCredentialParameters, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            registryName,
            regenerateCredentialParameters,
            options
        }, regenerateCredentialOperationSpec);
    }
    /**
     * Schedules a new run based on the request parameters and add it to the run queue.
     * @param resourceGroupName The name of the resource group to which the container registry belongs.
     * @param registryName The name of the container registry.
     * @param runRequest The parameters of a run that needs to scheduled.
     * @param options The options parameters.
     */
    beginScheduleRun(resourceGroupName, registryName, runRequest, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, registryName, runRequest, options }, scheduleRunOperationSpec);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Schedules a new run based on the request parameters and add it to the run queue.
     * @param resourceGroupName The name of the resource group to which the container registry belongs.
     * @param registryName The name of the container registry.
     * @param runRequest The parameters of a run that needs to scheduled.
     * @param options The options parameters.
     */
    beginScheduleRunAndWait(resourceGroupName, registryName, runRequest, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginScheduleRun(resourceGroupName, registryName, runRequest, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Get the upload location for the user to be able to upload the source.
     * @param resourceGroupName The name of the resource group to which the container registry belongs.
     * @param registryName The name of the container registry.
     * @param options The options parameters.
     */
    getBuildSourceUploadUrl(resourceGroupName, registryName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, registryName, options }, getBuildSourceUploadUrlOperationSpec);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName The name of the resource group to which the container registry belongs.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec);
    }
    /**
     * ListPrivateLinkResourcesNext
     * @param resourceGroupName The name of the resource group to which the container registry belongs.
     * @param registryName The name of the container registry.
     * @param nextLink The nextLink from the previous successful call to the ListPrivateLinkResources
     *                 method.
     * @param options The options parameters.
     */
    _listPrivateLinkResourcesNext(resourceGroupName, registryName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, registryName, nextLink, options }, listPrivateLinkResourcesNextOperationSpec);
    }
}
// Operation Specifications
const serializer = coreClient.createSerializer(Mappers, /* isXml */ false);
const importImageOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{registryName}/importImage",
    httpMethod: "POST",
    responses: { 200: {}, 201: {}, 202: {}, 204: {} },
    requestBody: parameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        registryName
    ],
    headerParameters: [contentType],
    mediaType: "json",
    serializer
};
const checkNameAvailabilityOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.ContainerRegistry/checkNameAvailability",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: RegistryNameStatus
        }
    },
    requestBody: registryNameCheckRequest,
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer
};
const listOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.ContainerRegistry/registries",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RegistryListResult
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer
};
const listByResourceGroupOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerRegistry/registries",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RegistryListResult
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer
};
const getOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{registryName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Registry
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        registryName
    ],
    headerParameters: [accept],
    serializer
};
const createOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{registryName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Registry
        },
        201: {
            bodyMapper: Registry
        },
        202: {
            bodyMapper: Registry
        },
        204: {
            bodyMapper: Registry
        }
    },
    requestBody: registry,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        registryName
    ],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer
};
const deleteOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{registryName}",
    httpMethod: "DELETE",
    responses: { 200: {}, 201: {}, 202: {}, 204: {} },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        registryName
    ],
    serializer
};
const updateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{registryName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: Registry
        },
        201: {
            bodyMapper: Registry
        },
        202: {
            bodyMapper: Registry
        },
        204: {
            bodyMapper: Registry
        }
    },
    requestBody: registryUpdateParameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        registryName
    ],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer
};
const listUsagesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{registryName}/listUsages",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RegistryUsageListResult
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        registryName
    ],
    headerParameters: [accept],
    serializer
};
const listPrivateLinkResourcesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{registryName}/privateLinkResources",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateLinkResourceListResult
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        registryName
    ],
    headerParameters: [accept],
    serializer
};
const getPrivateLinkResourceOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{registryName}/privateLinkResources/{groupName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateLinkResource
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        registryName,
        groupName
    ],
    headerParameters: [accept],
    serializer
};
const listCredentialsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{registryName}/listCredentials",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: RegistryListCredentialsResult
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        registryName
    ],
    headerParameters: [accept],
    serializer
};
const regenerateCredentialOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{registryName}/regenerateCredential",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: RegistryListCredentialsResult
        }
    },
    requestBody: regenerateCredentialParameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        registryName
    ],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer
};
const scheduleRunOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{registryName}/scheduleRun",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: Run
        },
        201: {
            bodyMapper: Run
        },
        202: {
            bodyMapper: Run
        },
        204: {
            bodyMapper: Run
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: runRequest,
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        registryName
    ],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer
};
const getBuildSourceUploadUrlOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{registryName}/listBuildSourceUploadUrl",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: SourceUploadDefinition
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        registryName
    ],
    headerParameters: [accept],
    serializer
};
const listNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RegistryListResult
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer
};
const listByResourceGroupNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RegistryListResult
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink
    ],
    headerParameters: [accept],
    serializer
};
const listPrivateLinkResourcesNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateLinkResourceListResult
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        registryName,
        nextLink
    ],
    headerParameters: [accept],
    serializer
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Operations operations. */
class OperationsImpl {
    /**
     * Initialize a new instance of the class Operations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all of the available Azure Container Registry REST API operations.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(options);
            }
        };
    }
    listPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all of the available Azure Container Registry REST API operations.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$1);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$1);
    }
}
// Operation Specifications
const serializer$1 = coreClient.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$1 = {
    path: "/providers/Microsoft.ContainerRegistry/operations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: OperationListResult
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host],
    headerParameters: [accept],
    serializer: serializer$1
};
const listNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: OperationListResult
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, nextLink],
    headerParameters: [accept],
    serializer: serializer$1
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing PrivateEndpointConnections operations. */
class PrivateEndpointConnectionsImpl {
    /**
     * Initialize a new instance of the class PrivateEndpointConnections class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List all private endpoint connections in a container registry.
     * @param resourceGroupName The name of the resource group to which the container registry belongs.
     * @param registryName The name of the container registry.
     * @param options The options parameters.
     */
    list(resourceGroupName, registryName, options) {
        const iter = this.listPagingAll(resourceGroupName, registryName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceGroupName, registryName, options);
            }
        };
    }
    listPagingPage(resourceGroupName, registryName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceGroupName, registryName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, registryName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(resourceGroupName, registryName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, registryName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List all private endpoint connections in a container registry.
     * @param resourceGroupName The name of the resource group to which the container registry belongs.
     * @param registryName The name of the container registry.
     * @param options The options parameters.
     */
    _list(resourceGroupName, registryName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, registryName, options }, listOperationSpec$2);
    }
    /**
     * Get the specified private endpoint connection associated with the container registry.
     * @param resourceGroupName The name of the resource group to which the container registry belongs.
     * @param registryName The name of the container registry.
     * @param privateEndpointConnectionName The name of the private endpoint connection.
     * @param options The options parameters.
     */
    get(resourceGroupName, registryName, privateEndpointConnectionName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            registryName,
            privateEndpointConnectionName,
            options
        }, getOperationSpec$1);
    }
    /**
     * Update the state of specified private endpoint connection associated with the container registry.
     * @param resourceGroupName The name of the resource group to which the container registry belongs.
     * @param registryName The name of the container registry.
     * @param privateEndpointConnectionName The name of the private endpoint connection.
     * @param privateEndpointConnection The parameters for creating a private endpoint connection.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, registryName, privateEndpointConnectionName, privateEndpointConnection, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                registryName,
                privateEndpointConnectionName,
                privateEndpointConnection,
                options
            }, createOrUpdateOperationSpec);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Update the state of specified private endpoint connection associated with the container registry.
     * @param resourceGroupName The name of the resource group to which the container registry belongs.
     * @param registryName The name of the container registry.
     * @param privateEndpointConnectionName The name of the private endpoint connection.
     * @param privateEndpointConnection The parameters for creating a private endpoint connection.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, registryName, privateEndpointConnectionName, privateEndpointConnection, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, registryName, privateEndpointConnectionName, privateEndpointConnection, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes the specified private endpoint connection associated with the container registry.
     * @param resourceGroupName The name of the resource group to which the container registry belongs.
     * @param registryName The name of the container registry.
     * @param privateEndpointConnectionName The name of the private endpoint connection.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, registryName, privateEndpointConnectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                registryName,
                privateEndpointConnectionName,
                options
            }, deleteOperationSpec$1);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Deletes the specified private endpoint connection associated with the container registry.
     * @param resourceGroupName The name of the resource group to which the container registry belongs.
     * @param registryName The name of the container registry.
     * @param privateEndpointConnectionName The name of the private endpoint connection.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, registryName, privateEndpointConnectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, registryName, privateEndpointConnectionName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group to which the container registry belongs.
     * @param registryName The name of the container registry.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, registryName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, registryName, nextLink, options }, listNextOperationSpec$2);
    }
}
// Operation Specifications
const serializer$2 = coreClient.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{registryName}/privateEndpointConnections",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateEndpointConnectionListResult
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        registryName
    ],
    headerParameters: [accept],
    serializer: serializer$2
};
const getOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{registryName}/privateEndpointConnections/{privateEndpointConnectionName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateEndpointConnection
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        registryName,
        privateEndpointConnectionName
    ],
    headerParameters: [accept],
    serializer: serializer$2
};
const createOrUpdateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{registryName}/privateEndpointConnections/{privateEndpointConnectionName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: PrivateEndpointConnection
        },
        201: {
            bodyMapper: PrivateEndpointConnection
        },
        202: {
            bodyMapper: PrivateEndpointConnection
        },
        204: {
            bodyMapper: PrivateEndpointConnection
        }
    },
    requestBody: privateEndpointConnection,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        registryName,
        privateEndpointConnectionName
    ],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer: serializer$2
};
const deleteOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{registryName}/privateEndpointConnections/{privateEndpointConnectionName}",
    httpMethod: "DELETE",
    responses: { 200: {}, 201: {}, 202: {}, 204: {} },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        registryName,
        privateEndpointConnectionName
    ],
    serializer: serializer$2
};
const listNextOperationSpec$2 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateEndpointConnectionListResult
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        registryName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$2
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Replications operations. */
class ReplicationsImpl {
    /**
     * Initialize a new instance of the class Replications class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all the replications for the specified container registry.
     * @param resourceGroupName The name of the resource group to which the container registry belongs.
     * @param registryName The name of the container registry.
     * @param options The options parameters.
     */
    list(resourceGroupName, registryName, options) {
        const iter = this.listPagingAll(resourceGroupName, registryName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceGroupName, registryName, options);
            }
        };
    }
    listPagingPage(resourceGroupName, registryName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceGroupName, registryName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, registryName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(resourceGroupName, registryName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, registryName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all the replications for the specified container registry.
     * @param resourceGroupName The name of the resource group to which the container registry belongs.
     * @param registryName The name of the container registry.
     * @param options The options parameters.
     */
    _list(resourceGroupName, registryName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, registryName, options }, listOperationSpec$3);
    }
    /**
     * Gets the properties of the specified replication.
     * @param resourceGroupName The name of the resource group to which the container registry belongs.
     * @param registryName The name of the container registry.
     * @param replicationName The name of the replication.
     * @param options The options parameters.
     */
    get(resourceGroupName, registryName, replicationName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, registryName, replicationName, options }, getOperationSpec$2);
    }
    /**
     * Creates a replication for a container registry with the specified parameters.
     * @param resourceGroupName The name of the resource group to which the container registry belongs.
     * @param registryName The name of the container registry.
     * @param replicationName The name of the replication.
     * @param replication The parameters for creating a replication.
     * @param options The options parameters.
     */
    beginCreate(resourceGroupName, registryName, replicationName, replication, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                registryName,
                replicationName,
                replication,
                options
            }, createOperationSpec$1);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Creates a replication for a container registry with the specified parameters.
     * @param resourceGroupName The name of the resource group to which the container registry belongs.
     * @param registryName The name of the container registry.
     * @param replicationName The name of the replication.
     * @param replication The parameters for creating a replication.
     * @param options The options parameters.
     */
    beginCreateAndWait(resourceGroupName, registryName, replicationName, replication, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreate(resourceGroupName, registryName, replicationName, replication, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes a replication from a container registry.
     * @param resourceGroupName The name of the resource group to which the container registry belongs.
     * @param registryName The name of the container registry.
     * @param replicationName The name of the replication.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, registryName, replicationName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, registryName, replicationName, options }, deleteOperationSpec$2);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Deletes a replication from a container registry.
     * @param resourceGroupName The name of the resource group to which the container registry belongs.
     * @param registryName The name of the container registry.
     * @param replicationName The name of the replication.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, registryName, replicationName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, registryName, replicationName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates a replication for a container registry with the specified parameters.
     * @param resourceGroupName The name of the resource group to which the container registry belongs.
     * @param registryName The name of the container registry.
     * @param replicationName The name of the replication.
     * @param replicationUpdateParameters The parameters for updating a replication.
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, registryName, replicationName, replicationUpdateParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                registryName,
                replicationName,
                replicationUpdateParameters,
                options
            }, updateOperationSpec$1);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Updates a replication for a container registry with the specified parameters.
     * @param resourceGroupName The name of the resource group to which the container registry belongs.
     * @param registryName The name of the container registry.
     * @param replicationName The name of the replication.
     * @param replicationUpdateParameters The parameters for updating a replication.
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, registryName, replicationName, replicationUpdateParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, registryName, replicationName, replicationUpdateParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group to which the container registry belongs.
     * @param registryName The name of the container registry.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, registryName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, registryName, nextLink, options }, listNextOperationSpec$3);
    }
}
// Operation Specifications
const serializer$3 = coreClient.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{registryName}/replications",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ReplicationListResult
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        registryName
    ],
    headerParameters: [accept],
    serializer: serializer$3
};
const getOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{registryName}/replications/{replicationName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Replication
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        registryName,
        replicationName
    ],
    headerParameters: [accept],
    serializer: serializer$3
};
const createOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{registryName}/replications/{replicationName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Replication
        },
        201: {
            bodyMapper: Replication
        },
        202: {
            bodyMapper: Replication
        },
        204: {
            bodyMapper: Replication
        }
    },
    requestBody: replication,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        registryName,
        replicationName
    ],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer: serializer$3
};
const deleteOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{registryName}/replications/{replicationName}",
    httpMethod: "DELETE",
    responses: { 200: {}, 201: {}, 202: {}, 204: {} },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        registryName,
        replicationName
    ],
    serializer: serializer$3
};
const updateOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{registryName}/replications/{replicationName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: Replication
        },
        201: {
            bodyMapper: Replication
        },
        202: {
            bodyMapper: Replication
        },
        204: {
            bodyMapper: Replication
        }
    },
    requestBody: replicationUpdateParameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        registryName,
        replicationName
    ],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer: serializer$3
};
const listNextOperationSpec$3 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ReplicationListResult
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        registryName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$3
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Webhooks operations. */
class WebhooksImpl {
    /**
     * Initialize a new instance of the class Webhooks class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all the webhooks for the specified container registry.
     * @param resourceGroupName The name of the resource group to which the container registry belongs.
     * @param registryName The name of the container registry.
     * @param options The options parameters.
     */
    list(resourceGroupName, registryName, options) {
        const iter = this.listPagingAll(resourceGroupName, registryName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceGroupName, registryName, options);
            }
        };
    }
    listPagingPage(resourceGroupName, registryName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceGroupName, registryName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, registryName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(resourceGroupName, registryName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, registryName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists recent events for the specified webhook.
     * @param resourceGroupName The name of the resource group to which the container registry belongs.
     * @param registryName The name of the container registry.
     * @param webhookName The name of the webhook.
     * @param options The options parameters.
     */
    listEvents(resourceGroupName, registryName, webhookName, options) {
        const iter = this.listEventsPagingAll(resourceGroupName, registryName, webhookName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listEventsPagingPage(resourceGroupName, registryName, webhookName, options);
            }
        };
    }
    listEventsPagingPage(resourceGroupName, registryName, webhookName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listEventsPagingPage_1() {
            let result = yield tslib.__await(this._listEvents(resourceGroupName, registryName, webhookName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listEventsNext(resourceGroupName, registryName, webhookName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listEventsPagingAll(resourceGroupName, registryName, webhookName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listEventsPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listEventsPagingPage(resourceGroupName, registryName, webhookName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Lists all the webhooks for the specified container registry.
     * @param resourceGroupName The name of the resource group to which the container registry belongs.
     * @param registryName The name of the container registry.
     * @param options The options parameters.
     */
    _list(resourceGroupName, registryName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, registryName, options }, listOperationSpec$4);
    }
    /**
     * Gets the properties of the specified webhook.
     * @param resourceGroupName The name of the resource group to which the container registry belongs.
     * @param registryName The name of the container registry.
     * @param webhookName The name of the webhook.
     * @param options The options parameters.
     */
    get(resourceGroupName, registryName, webhookName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, registryName, webhookName, options }, getOperationSpec$3);
    }
    /**
     * Creates a webhook for a container registry with the specified parameters.
     * @param resourceGroupName The name of the resource group to which the container registry belongs.
     * @param registryName The name of the container registry.
     * @param webhookName The name of the webhook.
     * @param webhookCreateParameters The parameters for creating a webhook.
     * @param options The options parameters.
     */
    beginCreate(resourceGroupName, registryName, webhookName, webhookCreateParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                registryName,
                webhookName,
                webhookCreateParameters,
                options
            }, createOperationSpec$2);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Creates a webhook for a container registry with the specified parameters.
     * @param resourceGroupName The name of the resource group to which the container registry belongs.
     * @param registryName The name of the container registry.
     * @param webhookName The name of the webhook.
     * @param webhookCreateParameters The parameters for creating a webhook.
     * @param options The options parameters.
     */
    beginCreateAndWait(resourceGroupName, registryName, webhookName, webhookCreateParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreate(resourceGroupName, registryName, webhookName, webhookCreateParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes a webhook from a container registry.
     * @param resourceGroupName The name of the resource group to which the container registry belongs.
     * @param registryName The name of the container registry.
     * @param webhookName The name of the webhook.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, registryName, webhookName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, registryName, webhookName, options }, deleteOperationSpec$3);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Deletes a webhook from a container registry.
     * @param resourceGroupName The name of the resource group to which the container registry belongs.
     * @param registryName The name of the container registry.
     * @param webhookName The name of the webhook.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, registryName, webhookName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, registryName, webhookName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates a webhook with the specified parameters.
     * @param resourceGroupName The name of the resource group to which the container registry belongs.
     * @param registryName The name of the container registry.
     * @param webhookName The name of the webhook.
     * @param webhookUpdateParameters The parameters for updating a webhook.
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, registryName, webhookName, webhookUpdateParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                registryName,
                webhookName,
                webhookUpdateParameters,
                options
            }, updateOperationSpec$2);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Updates a webhook with the specified parameters.
     * @param resourceGroupName The name of the resource group to which the container registry belongs.
     * @param registryName The name of the container registry.
     * @param webhookName The name of the webhook.
     * @param webhookUpdateParameters The parameters for updating a webhook.
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, registryName, webhookName, webhookUpdateParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, registryName, webhookName, webhookUpdateParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Triggers a ping event to be sent to the webhook.
     * @param resourceGroupName The name of the resource group to which the container registry belongs.
     * @param registryName The name of the container registry.
     * @param webhookName The name of the webhook.
     * @param options The options parameters.
     */
    ping(resourceGroupName, registryName, webhookName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, registryName, webhookName, options }, pingOperationSpec);
    }
    /**
     * Lists recent events for the specified webhook.
     * @param resourceGroupName The name of the resource group to which the container registry belongs.
     * @param registryName The name of the container registry.
     * @param webhookName The name of the webhook.
     * @param options The options parameters.
     */
    _listEvents(resourceGroupName, registryName, webhookName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, registryName, webhookName, options }, listEventsOperationSpec);
    }
    /**
     * Gets the configuration of service URI and custom headers for the webhook.
     * @param resourceGroupName The name of the resource group to which the container registry belongs.
     * @param registryName The name of the container registry.
     * @param webhookName The name of the webhook.
     * @param options The options parameters.
     */
    getCallbackConfig(resourceGroupName, registryName, webhookName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, registryName, webhookName, options }, getCallbackConfigOperationSpec);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group to which the container registry belongs.
     * @param registryName The name of the container registry.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, registryName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, registryName, nextLink, options }, listNextOperationSpec$4);
    }
    /**
     * ListEventsNext
     * @param resourceGroupName The name of the resource group to which the container registry belongs.
     * @param registryName The name of the container registry.
     * @param webhookName The name of the webhook.
     * @param nextLink The nextLink from the previous successful call to the ListEvents method.
     * @param options The options parameters.
     */
    _listEventsNext(resourceGroupName, registryName, webhookName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, registryName, webhookName, nextLink, options }, listEventsNextOperationSpec);
    }
}
// Operation Specifications
const serializer$4 = coreClient.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{registryName}/webhooks",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WebhookListResult
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        registryName
    ],
    headerParameters: [accept],
    serializer: serializer$4
};
const getOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{registryName}/webhooks/{webhookName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Webhook
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        registryName,
        webhookName
    ],
    headerParameters: [accept],
    serializer: serializer$4
};
const createOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{registryName}/webhooks/{webhookName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Webhook
        },
        201: {
            bodyMapper: Webhook
        },
        202: {
            bodyMapper: Webhook
        },
        204: {
            bodyMapper: Webhook
        }
    },
    requestBody: webhookCreateParameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        registryName,
        webhookName
    ],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer: serializer$4
};
const deleteOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{registryName}/webhooks/{webhookName}",
    httpMethod: "DELETE",
    responses: { 200: {}, 201: {}, 202: {}, 204: {} },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        registryName,
        webhookName
    ],
    serializer: serializer$4
};
const updateOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{registryName}/webhooks/{webhookName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: Webhook
        },
        201: {
            bodyMapper: Webhook
        },
        202: {
            bodyMapper: Webhook
        },
        204: {
            bodyMapper: Webhook
        }
    },
    requestBody: webhookUpdateParameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        registryName,
        webhookName
    ],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer: serializer$4
};
const pingOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{registryName}/webhooks/{webhookName}/ping",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: EventInfo
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        registryName,
        webhookName
    ],
    headerParameters: [accept],
    serializer: serializer$4
};
const listEventsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{registryName}/webhooks/{webhookName}/listEvents",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: EventListResult
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        registryName,
        webhookName
    ],
    headerParameters: [accept],
    serializer: serializer$4
};
const getCallbackConfigOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{registryName}/webhooks/{webhookName}/getCallbackConfig",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: CallbackConfig
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        registryName,
        webhookName
    ],
    headerParameters: [accept],
    serializer: serializer$4
};
const listNextOperationSpec$4 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WebhookListResult
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        registryName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$4
};
const listEventsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: EventListResult
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        registryName,
        nextLink,
        webhookName
    ],
    headerParameters: [accept],
    serializer: serializer$4
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing AgentPools operations. */
class AgentPoolsImpl {
    /**
     * Initialize a new instance of the class AgentPools class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all the agent pools for a specified container registry.
     * @param resourceGroupName The name of the resource group to which the container registry belongs.
     * @param registryName The name of the container registry.
     * @param options The options parameters.
     */
    list(resourceGroupName, registryName, options) {
        const iter = this.listPagingAll(resourceGroupName, registryName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceGroupName, registryName, options);
            }
        };
    }
    listPagingPage(resourceGroupName, registryName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceGroupName, registryName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, registryName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(resourceGroupName, registryName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, registryName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets the detailed information for a given agent pool.
     * @param resourceGroupName The name of the resource group to which the container registry belongs.
     * @param registryName The name of the container registry.
     * @param agentPoolName The name of the agent pool.
     * @param options The options parameters.
     */
    get(resourceGroupName, registryName, agentPoolName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, registryName, agentPoolName, options }, getOperationSpec$4);
    }
    /**
     * Creates an agent pool for a container registry with the specified parameters.
     * @param resourceGroupName The name of the resource group to which the container registry belongs.
     * @param registryName The name of the container registry.
     * @param agentPoolName The name of the agent pool.
     * @param agentPool The parameters of an agent pool that needs to scheduled.
     * @param options The options parameters.
     */
    beginCreate(resourceGroupName, registryName, agentPoolName, agentPool, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, registryName, agentPoolName, agentPool, options }, createOperationSpec$3);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Creates an agent pool for a container registry with the specified parameters.
     * @param resourceGroupName The name of the resource group to which the container registry belongs.
     * @param registryName The name of the container registry.
     * @param agentPoolName The name of the agent pool.
     * @param agentPool The parameters of an agent pool that needs to scheduled.
     * @param options The options parameters.
     */
    beginCreateAndWait(resourceGroupName, registryName, agentPoolName, agentPool, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreate(resourceGroupName, registryName, agentPoolName, agentPool, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes a specified agent pool resource.
     * @param resourceGroupName The name of the resource group to which the container registry belongs.
     * @param registryName The name of the container registry.
     * @param agentPoolName The name of the agent pool.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, registryName, agentPoolName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, registryName, agentPoolName, options }, deleteOperationSpec$4);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Deletes a specified agent pool resource.
     * @param resourceGroupName The name of the resource group to which the container registry belongs.
     * @param registryName The name of the container registry.
     * @param agentPoolName The name of the agent pool.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, registryName, agentPoolName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, registryName, agentPoolName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates an agent pool with the specified parameters.
     * @param resourceGroupName The name of the resource group to which the container registry belongs.
     * @param registryName The name of the container registry.
     * @param agentPoolName The name of the agent pool.
     * @param updateParameters The parameters for updating an agent pool.
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, registryName, agentPoolName, updateParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                registryName,
                agentPoolName,
                updateParameters,
                options
            }, updateOperationSpec$3);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Updates an agent pool with the specified parameters.
     * @param resourceGroupName The name of the resource group to which the container registry belongs.
     * @param registryName The name of the container registry.
     * @param agentPoolName The name of the agent pool.
     * @param updateParameters The parameters for updating an agent pool.
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, registryName, agentPoolName, updateParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, registryName, agentPoolName, updateParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Lists all the agent pools for a specified container registry.
     * @param resourceGroupName The name of the resource group to which the container registry belongs.
     * @param registryName The name of the container registry.
     * @param options The options parameters.
     */
    _list(resourceGroupName, registryName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, registryName, options }, listOperationSpec$5);
    }
    /**
     * Gets the count of queued runs for a given agent pool.
     * @param resourceGroupName The name of the resource group to which the container registry belongs.
     * @param registryName The name of the container registry.
     * @param agentPoolName The name of the agent pool.
     * @param options The options parameters.
     */
    getQueueStatus(resourceGroupName, registryName, agentPoolName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, registryName, agentPoolName, options }, getQueueStatusOperationSpec);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group to which the container registry belongs.
     * @param registryName The name of the container registry.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, registryName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, registryName, nextLink, options }, listNextOperationSpec$5);
    }
}
// Operation Specifications
const serializer$5 = coreClient.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{registryName}/agentPools/{agentPoolName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AgentPool
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        registryName,
        agentPoolName
    ],
    headerParameters: [accept],
    serializer: serializer$5
};
const createOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{registryName}/agentPools/{agentPoolName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: AgentPool
        },
        201: {
            bodyMapper: AgentPool
        },
        202: {
            bodyMapper: AgentPool
        },
        204: {
            bodyMapper: AgentPool
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: agentPool,
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        registryName,
        agentPoolName
    ],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer: serializer$5
};
const deleteOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{registryName}/agentPools/{agentPoolName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        registryName,
        agentPoolName
    ],
    headerParameters: [accept],
    serializer: serializer$5
};
const updateOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{registryName}/agentPools/{agentPoolName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: AgentPool
        },
        201: {
            bodyMapper: AgentPool
        },
        202: {
            bodyMapper: AgentPool
        },
        204: {
            bodyMapper: AgentPool
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: updateParameters,
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        registryName,
        agentPoolName
    ],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer: serializer$5
};
const listOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{registryName}/agentPools",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AgentPoolListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        registryName
    ],
    headerParameters: [accept],
    serializer: serializer$5
};
const getQueueStatusOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{registryName}/agentPools/{agentPoolName}/listQueueStatus",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: AgentPoolQueueStatus
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        registryName,
        agentPoolName
    ],
    headerParameters: [accept],
    serializer: serializer$5
};
const listNextOperationSpec$5 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AgentPoolListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        registryName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$5
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Runs operations. */
class RunsImpl {
    /**
     * Initialize a new instance of the class Runs class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all the runs for a registry.
     * @param resourceGroupName The name of the resource group to which the container registry belongs.
     * @param registryName The name of the container registry.
     * @param options The options parameters.
     */
    list(resourceGroupName, registryName, options) {
        const iter = this.listPagingAll(resourceGroupName, registryName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceGroupName, registryName, options);
            }
        };
    }
    listPagingPage(resourceGroupName, registryName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceGroupName, registryName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, registryName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(resourceGroupName, registryName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, registryName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets all the runs for a registry.
     * @param resourceGroupName The name of the resource group to which the container registry belongs.
     * @param registryName The name of the container registry.
     * @param options The options parameters.
     */
    _list(resourceGroupName, registryName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, registryName, options }, listOperationSpec$6);
    }
    /**
     * Gets the detailed information for a given run.
     * @param resourceGroupName The name of the resource group to which the container registry belongs.
     * @param registryName The name of the container registry.
     * @param runId The run ID.
     * @param options The options parameters.
     */
    get(resourceGroupName, registryName, runId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, registryName, runId, options }, getOperationSpec$5);
    }
    /**
     * Patch the run properties.
     * @param resourceGroupName The name of the resource group to which the container registry belongs.
     * @param registryName The name of the container registry.
     * @param runId The run ID.
     * @param runUpdateParameters The run update properties.
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, registryName, runId, runUpdateParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, registryName, runId, runUpdateParameters, options }, updateOperationSpec$4);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Patch the run properties.
     * @param resourceGroupName The name of the resource group to which the container registry belongs.
     * @param registryName The name of the container registry.
     * @param runId The run ID.
     * @param runUpdateParameters The run update properties.
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, registryName, runId, runUpdateParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, registryName, runId, runUpdateParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets a link to download the run logs.
     * @param resourceGroupName The name of the resource group to which the container registry belongs.
     * @param registryName The name of the container registry.
     * @param runId The run ID.
     * @param options The options parameters.
     */
    getLogSasUrl(resourceGroupName, registryName, runId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, registryName, runId, options }, getLogSasUrlOperationSpec);
    }
    /**
     * Cancel an existing run.
     * @param resourceGroupName The name of the resource group to which the container registry belongs.
     * @param registryName The name of the container registry.
     * @param runId The run ID.
     * @param options The options parameters.
     */
    beginCancel(resourceGroupName, registryName, runId, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, registryName, runId, options }, cancelOperationSpec);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Cancel an existing run.
     * @param resourceGroupName The name of the resource group to which the container registry belongs.
     * @param registryName The name of the container registry.
     * @param runId The run ID.
     * @param options The options parameters.
     */
    beginCancelAndWait(resourceGroupName, registryName, runId, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCancel(resourceGroupName, registryName, runId, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group to which the container registry belongs.
     * @param registryName The name of the container registry.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, registryName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, registryName, nextLink, options }, listNextOperationSpec$6);
    }
}
// Operation Specifications
const serializer$6 = coreClient.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{registryName}/runs",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RunListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion1, filter, top],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        registryName
    ],
    headerParameters: [accept],
    serializer: serializer$6
};
const getOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{registryName}/runs/{runId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Run
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        registryName,
        runId
    ],
    headerParameters: [accept],
    serializer: serializer$6
};
const updateOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{registryName}/runs/{runId}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: Run
        },
        201: {
            bodyMapper: Run
        },
        202: {
            bodyMapper: Run
        },
        204: {
            bodyMapper: Run
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: runUpdateParameters,
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        registryName,
        runId
    ],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer: serializer$6
};
const getLogSasUrlOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{registryName}/runs/{runId}/listLogSasUrl",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: RunGetLogResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        registryName,
        runId
    ],
    headerParameters: [accept],
    serializer: serializer$6
};
const cancelOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{registryName}/runs/{runId}/cancel",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        registryName,
        runId
    ],
    headerParameters: [accept],
    serializer: serializer$6
};
const listNextOperationSpec$6 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RunListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion1, filter, top],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        registryName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$6
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing TaskRuns operations. */
class TaskRunsImpl {
    /**
     * Initialize a new instance of the class TaskRuns class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all the task runs for a specified container registry.
     * @param resourceGroupName The name of the resource group to which the container registry belongs.
     * @param registryName The name of the container registry.
     * @param options The options parameters.
     */
    list(resourceGroupName, registryName, options) {
        const iter = this.listPagingAll(resourceGroupName, registryName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceGroupName, registryName, options);
            }
        };
    }
    listPagingPage(resourceGroupName, registryName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceGroupName, registryName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, registryName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(resourceGroupName, registryName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, registryName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets the detailed information for a given task run.
     * @param resourceGroupName The name of the resource group to which the container registry belongs.
     * @param registryName The name of the container registry.
     * @param taskRunName The name of the task run.
     * @param options The options parameters.
     */
    get(resourceGroupName, registryName, taskRunName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, registryName, taskRunName, options }, getOperationSpec$6);
    }
    /**
     * Creates a task run for a container registry with the specified parameters.
     * @param resourceGroupName The name of the resource group to which the container registry belongs.
     * @param registryName The name of the container registry.
     * @param taskRunName The name of the task run.
     * @param taskRun The parameters of a run that needs to scheduled.
     * @param options The options parameters.
     */
    beginCreate(resourceGroupName, registryName, taskRunName, taskRun, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, registryName, taskRunName, taskRun, options }, createOperationSpec$4);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Creates a task run for a container registry with the specified parameters.
     * @param resourceGroupName The name of the resource group to which the container registry belongs.
     * @param registryName The name of the container registry.
     * @param taskRunName The name of the task run.
     * @param taskRun The parameters of a run that needs to scheduled.
     * @param options The options parameters.
     */
    beginCreateAndWait(resourceGroupName, registryName, taskRunName, taskRun, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreate(resourceGroupName, registryName, taskRunName, taskRun, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes a specified task run resource.
     * @param resourceGroupName The name of the resource group to which the container registry belongs.
     * @param registryName The name of the container registry.
     * @param taskRunName The name of the task run.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, registryName, taskRunName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, registryName, taskRunName, options }, deleteOperationSpec$5);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Deletes a specified task run resource.
     * @param resourceGroupName The name of the resource group to which the container registry belongs.
     * @param registryName The name of the container registry.
     * @param taskRunName The name of the task run.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, registryName, taskRunName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, registryName, taskRunName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates a task run with the specified parameters.
     * @param resourceGroupName The name of the resource group to which the container registry belongs.
     * @param registryName The name of the container registry.
     * @param taskRunName The name of the task run.
     * @param updateParameters The parameters for updating a task run.
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, registryName, taskRunName, updateParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                registryName,
                taskRunName,
                updateParameters,
                options
            }, updateOperationSpec$5);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Updates a task run with the specified parameters.
     * @param resourceGroupName The name of the resource group to which the container registry belongs.
     * @param registryName The name of the container registry.
     * @param taskRunName The name of the task run.
     * @param updateParameters The parameters for updating a task run.
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, registryName, taskRunName, updateParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, registryName, taskRunName, updateParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the detailed information for a given task run that includes all secrets.
     * @param resourceGroupName The name of the resource group to which the container registry belongs.
     * @param registryName The name of the container registry.
     * @param taskRunName The name of the task run.
     * @param options The options parameters.
     */
    getDetails(resourceGroupName, registryName, taskRunName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, registryName, taskRunName, options }, getDetailsOperationSpec);
    }
    /**
     * Lists all the task runs for a specified container registry.
     * @param resourceGroupName The name of the resource group to which the container registry belongs.
     * @param registryName The name of the container registry.
     * @param options The options parameters.
     */
    _list(resourceGroupName, registryName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, registryName, options }, listOperationSpec$7);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group to which the container registry belongs.
     * @param registryName The name of the container registry.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, registryName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, registryName, nextLink, options }, listNextOperationSpec$7);
    }
}
// Operation Specifications
const serializer$7 = coreClient.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{registryName}/taskRuns/{taskRunName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: TaskRun
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        registryName,
        taskRunName
    ],
    headerParameters: [accept],
    serializer: serializer$7
};
const createOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{registryName}/taskRuns/{taskRunName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: TaskRun
        },
        201: {
            bodyMapper: TaskRun
        },
        202: {
            bodyMapper: TaskRun
        },
        204: {
            bodyMapper: TaskRun
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: taskRun,
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        registryName,
        taskRunName
    ],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer: serializer$7
};
const deleteOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{registryName}/taskRuns/{taskRunName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        registryName,
        taskRunName
    ],
    headerParameters: [accept],
    serializer: serializer$7
};
const updateOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{registryName}/taskRuns/{taskRunName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: TaskRun
        },
        201: {
            bodyMapper: TaskRun
        },
        202: {
            bodyMapper: TaskRun
        },
        204: {
            bodyMapper: TaskRun
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: updateParameters1,
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        registryName,
        taskRunName
    ],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer: serializer$7
};
const getDetailsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{registryName}/taskRuns/{taskRunName}/listDetails",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: TaskRun
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        registryName,
        taskRunName
    ],
    headerParameters: [accept],
    serializer: serializer$7
};
const listOperationSpec$7 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{registryName}/taskRuns",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: TaskRunListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        registryName
    ],
    headerParameters: [accept],
    serializer: serializer$7
};
const listNextOperationSpec$7 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: TaskRunListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        registryName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$7
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Tasks operations. */
class TasksImpl {
    /**
     * Initialize a new instance of the class Tasks class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all the tasks for a specified container registry.
     * @param resourceGroupName The name of the resource group to which the container registry belongs.
     * @param registryName The name of the container registry.
     * @param options The options parameters.
     */
    list(resourceGroupName, registryName, options) {
        const iter = this.listPagingAll(resourceGroupName, registryName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceGroupName, registryName, options);
            }
        };
    }
    listPagingPage(resourceGroupName, registryName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceGroupName, registryName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, registryName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(resourceGroupName, registryName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, registryName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all the tasks for a specified container registry.
     * @param resourceGroupName The name of the resource group to which the container registry belongs.
     * @param registryName The name of the container registry.
     * @param options The options parameters.
     */
    _list(resourceGroupName, registryName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, registryName, options }, listOperationSpec$8);
    }
    /**
     * Get the properties of a specified task.
     * @param resourceGroupName The name of the resource group to which the container registry belongs.
     * @param registryName The name of the container registry.
     * @param taskName The name of the container registry task.
     * @param options The options parameters.
     */
    get(resourceGroupName, registryName, taskName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, registryName, taskName, options }, getOperationSpec$7);
    }
    /**
     * Creates a task for a container registry with the specified parameters.
     * @param resourceGroupName The name of the resource group to which the container registry belongs.
     * @param registryName The name of the container registry.
     * @param taskName The name of the container registry task.
     * @param taskCreateParameters The parameters for creating a task.
     * @param options The options parameters.
     */
    beginCreate(resourceGroupName, registryName, taskName, taskCreateParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                registryName,
                taskName,
                taskCreateParameters,
                options
            }, createOperationSpec$5);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Creates a task for a container registry with the specified parameters.
     * @param resourceGroupName The name of the resource group to which the container registry belongs.
     * @param registryName The name of the container registry.
     * @param taskName The name of the container registry task.
     * @param taskCreateParameters The parameters for creating a task.
     * @param options The options parameters.
     */
    beginCreateAndWait(resourceGroupName, registryName, taskName, taskCreateParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreate(resourceGroupName, registryName, taskName, taskCreateParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes a specified task.
     * @param resourceGroupName The name of the resource group to which the container registry belongs.
     * @param registryName The name of the container registry.
     * @param taskName The name of the container registry task.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, registryName, taskName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, registryName, taskName, options }, deleteOperationSpec$6);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Deletes a specified task.
     * @param resourceGroupName The name of the resource group to which the container registry belongs.
     * @param registryName The name of the container registry.
     * @param taskName The name of the container registry task.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, registryName, taskName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, registryName, taskName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates a task with the specified parameters.
     * @param resourceGroupName The name of the resource group to which the container registry belongs.
     * @param registryName The name of the container registry.
     * @param taskName The name of the container registry task.
     * @param taskUpdateParameters The parameters for updating a task.
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, registryName, taskName, taskUpdateParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                registryName,
                taskName,
                taskUpdateParameters,
                options
            }, updateOperationSpec$6);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Updates a task with the specified parameters.
     * @param resourceGroupName The name of the resource group to which the container registry belongs.
     * @param registryName The name of the container registry.
     * @param taskName The name of the container registry task.
     * @param taskUpdateParameters The parameters for updating a task.
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, registryName, taskName, taskUpdateParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, registryName, taskName, taskUpdateParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Returns a task with extended information that includes all secrets.
     * @param resourceGroupName The name of the resource group to which the container registry belongs.
     * @param registryName The name of the container registry.
     * @param taskName The name of the container registry task.
     * @param options The options parameters.
     */
    getDetails(resourceGroupName, registryName, taskName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, registryName, taskName, options }, getDetailsOperationSpec$1);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group to which the container registry belongs.
     * @param registryName The name of the container registry.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, registryName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, registryName, nextLink, options }, listNextOperationSpec$8);
    }
}
// Operation Specifications
const serializer$8 = coreClient.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$8 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{registryName}/tasks",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: TaskListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        registryName
    ],
    headerParameters: [accept],
    serializer: serializer$8
};
const getOperationSpec$7 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{registryName}/tasks/{taskName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Task
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        registryName,
        taskName
    ],
    headerParameters: [accept],
    serializer: serializer$8
};
const createOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{registryName}/tasks/{taskName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Task
        },
        201: {
            bodyMapper: Task
        },
        202: {
            bodyMapper: Task
        },
        204: {
            bodyMapper: Task
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: taskCreateParameters,
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        registryName,
        taskName
    ],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer: serializer$8
};
const deleteOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{registryName}/tasks/{taskName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        registryName,
        taskName
    ],
    headerParameters: [accept],
    serializer: serializer$8
};
const updateOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{registryName}/tasks/{taskName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: Task
        },
        201: {
            bodyMapper: Task
        },
        202: {
            bodyMapper: Task
        },
        204: {
            bodyMapper: Task
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: taskUpdateParameters,
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        registryName,
        taskName
    ],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer: serializer$8
};
const getDetailsOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{registryName}/tasks/{taskName}/listDetails",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: Task
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        registryName,
        taskName
    ],
    headerParameters: [accept],
    serializer: serializer$8
};
const listNextOperationSpec$8 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: TaskListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        registryName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$8
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
class ContainerRegistryManagementClient extends coreClient.ServiceClient {
    /**
     * Initializes a new instance of the ContainerRegistryManagementClient class.
     * @param credentials Subscription credentials which uniquely identify client subscription.
     * @param subscriptionId The Microsoft Azure subscription ID.
     * @param options The parameter options
     */
    constructor(credentials, subscriptionId, options) {
        if (credentials === undefined) {
            throw new Error("'credentials' cannot be null");
        }
        if (subscriptionId === undefined) {
            throw new Error("'subscriptionId' cannot be null");
        }
        // Initializing default values for options
        if (!options) {
            options = {};
        }
        const defaults = {
            requestContentType: "application/json; charset=utf-8",
            credential: credentials
        };
        const packageDetails = `azsdk-js-arm-containerregistry/10.0.0`;
        const userAgentPrefix = options.userAgentOptions && options.userAgentOptions.userAgentPrefix
            ? `${options.userAgentOptions.userAgentPrefix} ${packageDetails}`
            : `${packageDetails}`;
        if (!options.credentialScopes) {
            options.credentialScopes = ["https://management.azure.com/.default"];
        }
        const optionsWithDefaults = Object.assign(Object.assign(Object.assign({}, defaults), options), { userAgentOptions: {
                userAgentPrefix
            }, baseUri: options.endpoint || "https://management.azure.com" });
        super(optionsWithDefaults);
        // Parameter assignments
        this.subscriptionId = subscriptionId;
        // Assigning values to Constant parameters
        this.$host = options.$host || "https://management.azure.com";
        this.registries = new RegistriesImpl(this);
        this.operations = new OperationsImpl(this);
        this.privateEndpointConnections = new PrivateEndpointConnectionsImpl(this);
        this.replications = new ReplicationsImpl(this);
        this.webhooks = new WebhooksImpl(this);
        this.agentPools = new AgentPoolsImpl(this);
        this.runs = new RunsImpl(this);
        this.taskRuns = new TaskRunsImpl(this);
        this.tasks = new TasksImpl(this);
    }
}

exports.ContainerRegistryManagementClient = ContainerRegistryManagementClient;
//# sourceMappingURL=index.js.map
